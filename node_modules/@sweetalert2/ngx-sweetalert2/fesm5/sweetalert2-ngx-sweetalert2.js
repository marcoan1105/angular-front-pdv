import Swal from 'sweetalert2';
import { InjectionToken, ChangeDetectionStrategy, Component, EventEmitter, Inject, Input, Output, ComponentFactoryResolver, Directive, HostListener, ViewContainerRef, TemplateRef, ApplicationRef, Host, Injector, NgModule } from '@angular/core';
import { __assign } from 'tslib';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Represents an object of targets for <swal> partials (use with *swalPartial directive).
 * We must use thunks to access the Swal.* functions listed below, because they get created after the first modal is
 * shown, so this object lets us reference those functions safely and in a statically-typed manner.
 */
var  /**
 * Represents an object of targets for <swal> partials (use with *swalPartial directive).
 * We must use thunks to access the Swal.* functions listed below, because they get created after the first modal is
 * shown, so this object lets us reference those functions safely and in a statically-typed manner.
 */
SwalPartialTargets = /** @class */ (function () {
    function SwalPartialTargets() {
        this.title = function () { return Swal.getTitle(); };
        this.content = function () { return Swal.getContent(); };
        this.actions = function () { return Swal.getActions(); };
        this.confirmButton = function () { return Swal.getConfirmButton(); };
        this.cancelButton = function () { return Swal.getCancelButton(); };
        this.footer = function () { return Swal.getFooter(); };
    }
    return SwalPartialTargets;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var SwalDefaults = new InjectionToken('SwalDefaults');
/**
 * @param {?=} options
 * @return {?}
 */
function swalDefaultsProvider(options) {
    if (options === void 0) { options = {}; }
    return {
        provide: SwalDefaults,
        useValue: options
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * <swal> component. See the README.md for usage.
 *
 * It contains a bunch of \@Inputs that have a perfect 1:1 mapping with SweetAlert2 options.
 * Their types are directly coming from SweetAlert2 types defintitions, meaning that ngx-sweetalert2 is tightly coupled
 * to SweetAlert2, but also is type-safe.
 *
 * /!\ Some SweetAlert options aren't \@Inputs but \@Outputs: onBeforeOpen, onOpen, and onClose (without "on*" prefix).
 *     However, preConfirm and inputValidtor are still \@Inputs because there are not event handlers, there can't be
 *     multiple listeners and we need the Promise they must return.
 *
 * /!\ You can notice that the SweetAlert2 `useRejections` and `expectRejections` are the only one to not have
 *     an \@Input(). That's because they are deprecated and not using the default value of these parameters leads to
 *     clunky control flow. They are supported (use [options]="{}"), but please don't use them.
 */
var SwalComponent = /** @class */ (function () {
    function SwalComponent(defaultSwalOptions) {
        this.defaultSwalOptions = defaultSwalOptions;
        /**
         * Emits a BeforeOpenEvent when the modal DOM element has been created.
         * Useful to perform DOM mutations before the modal is shown.
         */
        this.beforeOpen = new EventEmitter();
        /**
         * Emits an OpenEvent when the modal is shown.
         */
        this.open = new EventEmitter();
        /**
         * Emits a CloseEvent when modal get closed.
         */
        this.close = new EventEmitter();
        /**
         * Emits when the user clicks "Confirm".
         * Bears a value when using "input", resolved "preConfirm", etc.
         *
         * Example:
         *     public handleConfirm(email: string): void {
         *         // ... save user email
         *     }
         */
        this.confirm = new EventEmitter();
        /**
         * Emits when the user clicks "Cancel" (or dismisses the modal by any other way).
         * By default, it will emit a string representing the reason for which the SweetAlert has been closed, or the
         * value of a rejected "preConfirm".
         *
         * Example:
         *     public handleCancel(reason: string): void {
         *         // reason can be 'cancel', 'overlay', 'close', and 'timer'
         *         // ... do something
         *     }
         */
        this.cancel = new EventEmitter();
        this.nativeSwal = Swal;
        this.isCurrentlyShown = false;
        this.touchedProps = new Set();
        this.markTouched = this.touchedProps.add.bind(this.touchedProps);
        //=> Force `this` scope of show() on this component
        //   Useful for doing things like (click)="mySwal.show()".
        this.show = this.show.bind(this);
    }
    Object.defineProperty(SwalComponent.prototype, "options", {
        get: /**
         * @return {?}
         */
        function () {
            var _this = this;
            /** @type {?} */
            var options = {};
            //=> We will compute the options object based on the option keys that are known to have changed.
            // That avoids passing a gigantic object to SweetAlert2, making debugging easier and potentially avoiding
            // side effects.
            this.touchedProps.forEach(function (prop) {
                options[prop] = ((/** @type {?} */ (_this)))[prop];
            });
            return options;
        },
        /**
         * An object of SweetAlert2 native options, useful if:
         *  - you don't want to use the @Inputs for practical/philosophical reasons ;
         *  - there are missing @Inputs because ngx-sweetalert2 isn't up-to-date with SweetAlert2's latest changes.
         *
         * /!\ Be aware that the options defined in this object will override the @Inputs of the same name.
         */
        set: /**
         * An object of SweetAlert2 native options, useful if:
         *  - you don't want to use the \@Inputs for practical/philosophical reasons ;
         *  - there are missing \@Inputs because ngx-sweetalert2 isn't up-to-date with SweetAlert2's latest changes.
         *
         * /!\ Be aware that the options defined in this object will override the \@Inputs of the same name.
         * @param {?} options
         * @return {?}
         */
        function (options) {
            Object.assign(this, options);
            Object.keys(options).forEach(this.markTouched);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} changes
     * @return {?}
     */
    SwalComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        Object.keys(changes)
            .filter(function (prop) { return prop !== 'options'; })
            .forEach(this.markTouched);
    };
    /**
     * @return {?}
     */
    SwalComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.isCurrentlyShown) {
            Swal.close();
        }
    };
    /**
     * Shows the SweetAlert.
     *
     * Returns the SweetAlert2 promise for convenience and use in code behind templates.
     * Otherwise, (confirm)="myHandler($event)" and (cancel)="myHandler($event)" can be used in templates.
     */
    /**
     * Shows the SweetAlert.
     *
     * Returns the SweetAlert2 promise for convenience and use in code behind templates.
     * Otherwise, (confirm)="myHandler($event)" and (cancel)="myHandler($event)" can be used in templates.
     * @return {?}
     */
    SwalComponent.prototype.show = /**
     * Shows the SweetAlert.
     *
     * Returns the SweetAlert2 promise for convenience and use in code behind templates.
     * Otherwise, (confirm)="myHandler($event)" and (cancel)="myHandler($event)" can be used in templates.
     * @return {?}
     */
    function () {
        var _this = this;
        //=> Build the SweetAlert2 options
        /** @type {?} */
        var options = __assign({}, this.defaultSwalOptions, this.options, { onBeforeOpen: function (modalElement) {
                _this.beforeOpen.emit({ modalElement: modalElement });
            }, onOpen: function (modalElement) {
                _this.isCurrentlyShown = true;
                _this.open.emit({ modalElement: modalElement });
            }, onClose: function (modalElement) {
                _this.isCurrentlyShown = false;
                _this.close.emit({ modalElement: modalElement });
            } });
        //=> Show the Swal!
        /** @type {?} */
        var promise = Swal.fire(options);
        //=> Handle (confirm) and (cancel) @Outputs
        // tslint:disable-next-line:no-string-literal
        /** @type {?} */
        var useRejections = ((/** @type {?} */ (options))).useRejections;
        promise.then(function (result) {
            if (useRejections) {
                _this.confirm.emit(result);
            }
            else if ('value' in result) {
                _this.confirm.emit(result.value);
            }
            else {
                _this.cancel.emit(result.dismiss);
            }
        }, function (err) {
            if (useRejections) {
                _this.cancel.emit(err);
            }
        });
        //=> Return the unaltered promise
        return promise;
    };
    SwalComponent.decorators = [
        { type: Component, args: [{
                    selector: 'swal',
                    template: '',
                    changeDetection: ChangeDetectionStrategy.OnPush
                }] }
    ];
    /** @nocollapse */
    SwalComponent.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [SwalDefaults,] }] }
    ]; };
    SwalComponent.propDecorators = {
        title: [{ type: Input }],
        titleText: [{ type: Input }],
        text: [{ type: Input }],
        html: [{ type: Input }],
        footer: [{ type: Input }],
        type: [{ type: Input }],
        backdrop: [{ type: Input }],
        toast: [{ type: Input }],
        target: [{ type: Input }],
        input: [{ type: Input }],
        width: [{ type: Input }],
        padding: [{ type: Input }],
        background: [{ type: Input }],
        position: [{ type: Input }],
        grow: [{ type: Input }],
        customClass: [{ type: Input }],
        timer: [{ type: Input }],
        animation: [{ type: Input }],
        allowOutsideClick: [{ type: Input }],
        allowEscapeKey: [{ type: Input }],
        allowEnterKey: [{ type: Input }],
        showConfirmButton: [{ type: Input }],
        showCancelButton: [{ type: Input }],
        confirmButtonText: [{ type: Input }],
        cancelButtonText: [{ type: Input }],
        confirmButtonColor: [{ type: Input }],
        cancelButtonColor: [{ type: Input }],
        confirmButtonClass: [{ type: Input }],
        cancelButtonClass: [{ type: Input }],
        confirmButtonAriaLabel: [{ type: Input }],
        cancelButtonAriaLabel: [{ type: Input }],
        buttonsStyling: [{ type: Input }],
        reverseButtons: [{ type: Input }],
        focusConfirm: [{ type: Input }],
        focusCancel: [{ type: Input }],
        showCloseButton: [{ type: Input }],
        closeButtonAriaLabel: [{ type: Input }],
        showLoaderOnConfirm: [{ type: Input }],
        preConfirm: [{ type: Input }],
        imageUrl: [{ type: Input }],
        imageWidth: [{ type: Input }],
        imageHeight: [{ type: Input }],
        imageAlt: [{ type: Input }],
        imageClass: [{ type: Input }],
        inputPlaceholder: [{ type: Input }],
        inputValue: [{ type: Input }],
        inputOptions: [{ type: Input }],
        inputAutoTrim: [{ type: Input }],
        inputAttributes: [{ type: Input }],
        inputValidator: [{ type: Input }],
        inputClass: [{ type: Input }],
        progressSteps: [{ type: Input }],
        currentProgressStep: [{ type: Input }],
        progressStepsDistance: [{ type: Input }],
        beforeOpen: [{ type: Output }],
        open: [{ type: Output }],
        close: [{ type: Output }],
        confirm: [{ type: Output }],
        cancel: [{ type: Output }],
        options: [{ type: Input }]
    };
    return SwalComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * [swal] directive. It takes a value that defines the Sweet Alert and can be of three types:
 *
 * 1) A simple array of two or three strings defining [title, text, type] - the type being optional, ex:
 *
 *    <button [swal]="['Title', 'Text']">Click me</button>
 *
 * 2) A native SweetAlert2 options object, ex:
 *
 *    <button [swal]="{ title: 'Title', text: 'Text' }">Click me</button>
 *
 * 3) A reference to an existing SwalComponent instance for more advanced uses, ex:
 *
 *    <button [swal]="mySwal">Click me</button>
 *    <swal #mySwal title="Title" text="Text"></swal>
 */
var SwalDirective = /** @class */ (function () {
    function SwalDirective(viewContainerRef, resolver) {
        this.viewContainerRef = viewContainerRef;
        this.resolver = resolver;
        /**
         * Emits when the user clicks "Confirm".
         * Bears a value when using "input", resolved "preConfirm", etc.
         *
         * Example:
         *     public handleConfirm(email: string): void {
         *         // ... save user email
         *     }
         */
        this.confirm = new EventEmitter();
        /**
         * Emits when the user clicks "Cancel" (or dismisses the modal by any other way).
         * By default, it will emit a string representing the reason for which the SweetAlert has been closed, or the
         * value of a rejected "preConfirm".
         *
         * Example:
         *     public handleCancel(reason: string): void {
         *         // reason can be 'cancel', 'overlay', 'close', and 'timer'
         *         // ... do something
         *     }
         */
        this.cancel = new EventEmitter();
    }
    Object.defineProperty(SwalDirective.prototype, "swal", {
        /**
         * SweetAlert2 options or a SwalComponent instance.
         * See the class doc block for more informations.
         */
        set: /**
         * SweetAlert2 options or a SwalComponent instance.
         * See the class doc block for more informations.
         * @param {?} options
         * @return {?}
         */
        function (options) {
            if (options instanceof SwalComponent) {
                this.swalInstance = options;
            }
            else if (Array.isArray(options)) {
                this.swalOptions = Swal.argsToParams(options);
            }
            else {
                this.swalOptions = options;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * OnInit lifecycle handler.
     * Creates a SwalComponent instance if the user didn't provided one and binds on that component (confirm) and
     * (cancel) outputs to reemit on the directive.
     */
    /**
     * OnInit lifecycle handler.
     * Creates a SwalComponent instance if the user didn't provided one and binds on that component (confirm) and
     * (cancel) outputs to reemit on the directive.
     * @return {?}
     */
    SwalDirective.prototype.ngOnInit = /**
     * OnInit lifecycle handler.
     * Creates a SwalComponent instance if the user didn't provided one and binds on that component (confirm) and
     * (cancel) outputs to reemit on the directive.
     * @return {?}
     */
    function () {
        if (!this.swalInstance) {
            /** @type {?} */
            var factory = this.resolver.resolveComponentFactory(SwalComponent);
            this.swalRef = this.viewContainerRef.createComponent(factory);
            this.swalInstance = this.swalRef.instance;
        }
    };
    /**
     * OnDestroy lifecycle handler.
     * Destroys the dynamically-created SwalComponent and unsubscribes from that component's (confirm) and (cancel).
     */
    /**
     * OnDestroy lifecycle handler.
     * Destroys the dynamically-created SwalComponent and unsubscribes from that component's (confirm) and (cancel).
     * @return {?}
     */
    SwalDirective.prototype.ngOnDestroy = /**
     * OnDestroy lifecycle handler.
     * Destroys the dynamically-created SwalComponent and unsubscribes from that component's (confirm) and (cancel).
     * @return {?}
     */
    function () {
        if (this.swalRef) {
            this.swalRef.destroy();
        }
    };
    /**
     * Click handler.
     * The directive listens for onclick events on its host element.
     * When this happens, it shows the <swal> attached to this directive.
     */
    /**
     * Click handler.
     * The directive listens for onclick events on its host element.
     * When this happens, it shows the <swal> attached to this directive.
     * @param {?} event
     * @return {?}
     */
    SwalDirective.prototype.onHostClicked = /**
     * Click handler.
     * The directive listens for onclick events on its host element.
     * When this happens, it shows the <swal> attached to this directive.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        event.preventDefault();
        event.stopImmediatePropagation();
        event.stopPropagation();
        if (this.swalOptions) {
            this.swalInstance.options = this.swalOptions;
        }
        /** @type {?} */
        var confirmSub = this.swalInstance.confirm.asObservable().subscribe(function (v) { return _this.confirm.emit(v); });
        /** @type {?} */
        var cancelSub = this.swalInstance.cancel.asObservable().subscribe(function (v) { return _this.cancel.emit(v); });
        this.swalInstance.show().then(unsubscribe);
        /**
         * @return {?}
         */
        function unsubscribe() {
            confirmSub.unsubscribe();
            cancelSub.unsubscribe();
        }
    };
    SwalDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[swal]'
                },] }
    ];
    /** @nocollapse */
    SwalDirective.ctorParameters = function () { return [
        { type: ViewContainerRef },
        { type: ComponentFactoryResolver }
    ]; };
    SwalDirective.propDecorators = {
        swal: [{ type: Input }],
        confirm: [{ type: Output }],
        cancel: [{ type: Output }],
        onHostClicked: [{ type: HostListener, args: ['click', ['$event'],] }]
    };
    return SwalDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * \@internal
 * Holds a consumer's Angular template and displays it on a Sweet Alert.
 * See SwalPartialDirective for info about the covered feature.
 */
var SwalPartialComponent = /** @class */ (function () {
    function SwalPartialComponent() {
    }
    SwalPartialComponent.decorators = [
        { type: Component, args: [{
                    template: '<ng-container *ngTemplateOutlet="template"></ng-container>',
                    changeDetection: ChangeDetectionStrategy.OnPush
                }] }
    ];
    SwalPartialComponent.propDecorators = {
        template: [{ type: Input }]
    };
    return SwalPartialComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * A structural directive that lets you use Angular templates inside of Sweet Alerts.
 * There are different targetable zones in a Sweet Alert: title, content, confirmButton, cancelButton, buttonsWrapper.
 * The default target is the content zone.
 *
 * Usage in your component's TypeScript code-behind (if you use another target than "content"):
 *
 * \@Component({ ... })
 *     export class MyComponent {
 *         public constructor(public readonly swalTargets: SwalPartialTargets) {
 *         }
 *     }
 *
 * Usage in the template:
 *
 *     <swal title="Fill the form" (confirm)="confirmHandler()">
 *         <!-- This form will be displayed as the alert main content
 *              Targets the alert's main content zone by default -->
 *         <form *swalPartial [formControl]="myForm">
 *             ...
 *         </form>
 *
 *         <!-- This targets the confirm button's inner content
 *              Notice the usage of ng-container to avoid creating an useless DOM element inside the button -->
 *         <ng-container *swalPartial="swalTargets.confirmButton">
 *              Send ({{ secondsLeft }} seconds left)
 *         </ng-container>
 *     <swal>
 */
var SwalPartialDirective = /** @class */ (function () {
    function SwalPartialDirective(resolver, injector, app, templateRef, swalTargets, swalComponent) {
        this.resolver = resolver;
        this.injector = injector;
        this.app = app;
        this.templateRef = templateRef;
        this.swalTargets = swalTargets;
        this.swalComponent = swalComponent;
    }
    /**
     * Subscribes to the the Sweet Alert appearance/disappearance to create/destroy the SwalPartialComponent that will
     * receive the consumer's template.
     */
    /**
     * Subscribes to the the Sweet Alert appearance/disappearance to create/destroy the SwalPartialComponent that will
     * receive the consumer's template.
     * @return {?}
     */
    SwalPartialDirective.prototype.ngOnInit = /**
     * Subscribes to the the Sweet Alert appearance/disappearance to create/destroy the SwalPartialComponent that will
     * receive the consumer's template.
     * @return {?}
     */
    function () {
        var _this = this;
        this.beforeOpenSubscription = this.swalComponent.beforeOpen.asObservable().subscribe(function () {
            //=> Create the SwalPartialComponent on the target DOM node in the Sweet Alert
            /** @type {?} */
            var targetEl = _this.swalPartial ? _this.swalPartial() : _this.swalTargets.content();
            /** @type {?} */
            var factory = _this.resolver.resolveComponentFactory(SwalPartialComponent);
            _this.partialRef = factory.create(_this.injector, [], targetEl);
            //=> Apply the consumer's template on the component
            _this.partialRef.instance.template = _this.templateRef;
            //=> Make the Angular app aware of that detached view so change detection works
            _this.app.attachView(_this.partialRef.hostView);
        });
        this.closeSubscription = this.swalComponent.close.asObservable().subscribe(function () {
            //=> Detach the partial component from the app and destroy it
            _this.app.detachView(_this.partialRef.hostView);
            _this.partialRef.destroy();
        });
    };
    /**
     * Unsubscribes from the Sweet Alert appearance/disappearance.
     */
    /**
     * Unsubscribes from the Sweet Alert appearance/disappearance.
     * @return {?}
     */
    SwalPartialDirective.prototype.ngOnDestroy = /**
     * Unsubscribes from the Sweet Alert appearance/disappearance.
     * @return {?}
     */
    function () {
        this.beforeOpenSubscription.unsubscribe();
        this.closeSubscription.unsubscribe();
    };
    SwalPartialDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[swalPartial]'
                },] }
    ];
    /** @nocollapse */
    SwalPartialDirective.ctorParameters = function () { return [
        { type: ComponentFactoryResolver },
        { type: Injector },
        { type: ApplicationRef },
        { type: TemplateRef },
        { type: SwalPartialTargets },
        { type: SwalComponent, decorators: [{ type: Host }] }
    ]; };
    SwalPartialDirective.propDecorators = {
        swalPartial: [{ type: Input }]
    };
    return SwalPartialDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var SweetAlert2Module = /** @class */ (function () {
    function SweetAlert2Module() {
    }
    /**
     * @param {?=} defaultSwalOptions
     * @return {?}
     */
    SweetAlert2Module.forRoot = /**
     * @param {?=} defaultSwalOptions
     * @return {?}
     */
    function (defaultSwalOptions) {
        return {
            ngModule: SweetAlert2Module,
            providers: [swalDefaultsProvider(defaultSwalOptions)]
        };
    };
    SweetAlert2Module.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        SwalComponent, SwalPartialDirective, SwalPartialComponent,
                        SwalDirective
                    ],
                    providers: [
                        SwalPartialTargets
                    ],
                    imports: [
                        CommonModule
                    ],
                    exports: [
                        SwalComponent, SwalPartialDirective,
                        SwalDirective
                    ],
                    entryComponents: [
                        SwalComponent, SwalPartialComponent
                    ]
                },] }
    ];
    return SweetAlert2Module;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

export { SwalPartialTargets, SwalComponent, SwalDirective, SwalPartialDirective, SweetAlert2Module, SwalDefaults as ɵa, swalDefaultsProvider as ɵb, SwalPartialComponent as ɵc };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3dlZXRhbGVydDItbmd4LXN3ZWV0YWxlcnQyLmpzLm1hcCIsInNvdXJjZXMiOlsibmc6Ly9Ac3dlZXRhbGVydDIvbmd4LXN3ZWV0YWxlcnQyL3N3YWwtcGFydGlhbC10YXJnZXRzLnRzIiwibmc6Ly9Ac3dlZXRhbGVydDIvbmd4LXN3ZWV0YWxlcnQyL2RpLnRzIiwibmc6Ly9Ac3dlZXRhbGVydDIvbmd4LXN3ZWV0YWxlcnQyL3N3YWwuY29tcG9uZW50LnRzIiwibmc6Ly9Ac3dlZXRhbGVydDIvbmd4LXN3ZWV0YWxlcnQyL3N3YWwuZGlyZWN0aXZlLnRzIiwibmc6Ly9Ac3dlZXRhbGVydDIvbmd4LXN3ZWV0YWxlcnQyL3N3YWwtcGFydGlhbC5jb21wb25lbnQudHMiLCJuZzovL0Bzd2VldGFsZXJ0Mi9uZ3gtc3dlZXRhbGVydDIvc3dhbC1wYXJ0aWFsLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHN3ZWV0YWxlcnQyL25neC1zd2VldGFsZXJ0Mi9zd2VldGFsZXJ0Mi5tb2R1bGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFN3YWwgZnJvbSAnc3dlZXRhbGVydDInO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gb2JqZWN0IG9mIHRhcmdldHMgZm9yIDxzd2FsPiBwYXJ0aWFscyAodXNlIHdpdGggKnN3YWxQYXJ0aWFsIGRpcmVjdGl2ZSkuXG4gKiBXZSBtdXN0IHVzZSB0aHVua3MgdG8gYWNjZXNzIHRoZSBTd2FsLiogZnVuY3Rpb25zIGxpc3RlZCBiZWxvdywgYmVjYXVzZSB0aGV5IGdldCBjcmVhdGVkIGFmdGVyIHRoZSBmaXJzdCBtb2RhbCBpc1xuICogc2hvd24sIHNvIHRoaXMgb2JqZWN0IGxldHMgdXMgcmVmZXJlbmNlIHRob3NlIGZ1bmN0aW9ucyBzYWZlbHkgYW5kIGluIGEgc3RhdGljYWxseS10eXBlZCBtYW5uZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBTd2FsUGFydGlhbFRhcmdldHMge1xuICAgIHB1YmxpYyByZWFkb25seSB0aXRsZSA9ICgpID0+IFN3YWwuZ2V0VGl0bGUoKTtcblxuICAgIHB1YmxpYyByZWFkb25seSBjb250ZW50ID0gKCkgPT4gU3dhbC5nZXRDb250ZW50KCk7XG5cbiAgICBwdWJsaWMgcmVhZG9ubHkgYWN0aW9ucyA9ICgpID0+IFN3YWwuZ2V0QWN0aW9ucygpO1xuXG4gICAgcHVibGljIHJlYWRvbmx5IGNvbmZpcm1CdXR0b24gPSAoKSA9PiBTd2FsLmdldENvbmZpcm1CdXR0b24oKTtcblxuICAgIHB1YmxpYyByZWFkb25seSBjYW5jZWxCdXR0b24gPSAoKSA9PiBTd2FsLmdldENhbmNlbEJ1dHRvbigpO1xuXG4gICAgcHVibGljIHJlYWRvbmx5IGZvb3RlciA9ICgpID0+IFN3YWwuZ2V0Rm9vdGVyKCk7XG59XG4iLCJpbXBvcnQgeyBJbmplY3Rpb25Ub2tlbiwgUHJvdmlkZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN3ZWV0QWxlcnRPcHRpb25zIH0gZnJvbSAnc3dlZXRhbGVydDInO1xuXG5leHBvcnQgY29uc3QgU3dhbERlZmF1bHRzID0gbmV3IEluamVjdGlvblRva2VuPFN3ZWV0QWxlcnRPcHRpb25zPignU3dhbERlZmF1bHRzJyk7XG5cbmV4cG9ydCBmdW5jdGlvbiBzd2FsRGVmYXVsdHNQcm92aWRlcihvcHRpb25zOiBTd2VldEFsZXJ0T3B0aW9ucyA9IHt9KTogUHJvdmlkZXIge1xuICAgIHJldHVybiB7XG4gICAgICAgIHByb3ZpZGU6IFN3YWxEZWZhdWx0cyxcbiAgICAgICAgdXNlVmFsdWU6IG9wdGlvbnNcbiAgICB9O1xufVxuIiwiaW1wb3J0IHtcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIEluamVjdCwgSW5wdXQsIE9uQ2hhbmdlcywgT25EZXN0cm95LCBPdXRwdXQsIFNpbXBsZUNoYW5nZXNcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgU3dhbCwgeyBTd2VldEFsZXJ0T3B0aW9ucyB9IGZyb20gJ3N3ZWV0YWxlcnQyJztcbmltcG9ydCB7IFN3YWxEZWZhdWx0cyB9IGZyb20gJy4vZGknO1xuaW1wb3J0ICogYXMgZXZlbnRzIGZyb20gJy4vc3dhbC1ldmVudHMnO1xuXG4vKipcbiAqIDxzd2FsPiBjb21wb25lbnQuIFNlZSB0aGUgUkVBRE1FLm1kIGZvciB1c2FnZS5cbiAqXG4gKiBJdCBjb250YWlucyBhIGJ1bmNoIG9mIEBJbnB1dHMgdGhhdCBoYXZlIGEgcGVyZmVjdCAxOjEgbWFwcGluZyB3aXRoIFN3ZWV0QWxlcnQyIG9wdGlvbnMuXG4gKiBUaGVpciB0eXBlcyBhcmUgZGlyZWN0bHkgY29taW5nIGZyb20gU3dlZXRBbGVydDIgdHlwZXMgZGVmaW50aXRpb25zLCBtZWFuaW5nIHRoYXQgbmd4LXN3ZWV0YWxlcnQyIGlzIHRpZ2h0bHkgY291cGxlZFxuICogdG8gU3dlZXRBbGVydDIsIGJ1dCBhbHNvIGlzIHR5cGUtc2FmZS5cbiAqXG4gKiAvIVxcIFNvbWUgU3dlZXRBbGVydCBvcHRpb25zIGFyZW4ndCBASW5wdXRzIGJ1dCBAT3V0cHV0czogb25CZWZvcmVPcGVuLCBvbk9wZW4sIGFuZCBvbkNsb3NlICh3aXRob3V0IFwib24qXCIgcHJlZml4KS5cbiAqICAgICBIb3dldmVyLCBwcmVDb25maXJtIGFuZCBpbnB1dFZhbGlkdG9yIGFyZSBzdGlsbCBASW5wdXRzIGJlY2F1c2UgdGhlcmUgYXJlIG5vdCBldmVudCBoYW5kbGVycywgdGhlcmUgY2FuJ3QgYmVcbiAqICAgICBtdWx0aXBsZSBsaXN0ZW5lcnMgYW5kIHdlIG5lZWQgdGhlIFByb21pc2UgdGhleSBtdXN0IHJldHVybi5cbiAqXG4gKiAvIVxcIFlvdSBjYW4gbm90aWNlIHRoYXQgdGhlIFN3ZWV0QWxlcnQyIGB1c2VSZWplY3Rpb25zYCBhbmQgYGV4cGVjdFJlamVjdGlvbnNgIGFyZSB0aGUgb25seSBvbmUgdG8gbm90IGhhdmVcbiAqICAgICBhbiBASW5wdXQoKS4gVGhhdCdzIGJlY2F1c2UgdGhleSBhcmUgZGVwcmVjYXRlZCBhbmQgbm90IHVzaW5nIHRoZSBkZWZhdWx0IHZhbHVlIG9mIHRoZXNlIHBhcmFtZXRlcnMgbGVhZHMgdG9cbiAqICAgICBjbHVua3kgY29udHJvbCBmbG93LiBUaGV5IGFyZSBzdXBwb3J0ZWQgKHVzZSBbb3B0aW9uc109XCJ7fVwiKSwgYnV0IHBsZWFzZSBkb24ndCB1c2UgdGhlbS5cbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdzd2FsJyxcbiAgICB0ZW1wbGF0ZTogJycsXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgU3dhbENvbXBvbmVudCBpbXBsZW1lbnRzIE9uQ2hhbmdlcywgT25EZXN0cm95IHtcbiAgICAvLyBJZiBTd2FsIGdldHMgbW9yZSB0aGFuIGEgaHVuZHJlZCBwcm9wcywgSSdsbCB3cml0ZSBhIGNvZGUgZ2VuZXJhdG9yLCBJIHByb21pc2UuXG4gICAgLy8gQW5kIEkgYWx3YXlzIHJlc29sdmUoKSBteSBwcm9taXNlcy5cbiAgICBASW5wdXQoKSBwdWJsaWMgdGl0bGU6IFN3ZWV0QWxlcnRPcHRpb25zWyd0aXRsZSddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyB0aXRsZVRleHQ6IFN3ZWV0QWxlcnRPcHRpb25zWyd0aXRsZVRleHQnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgdGV4dDogU3dlZXRBbGVydE9wdGlvbnNbJ3RleHQnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaHRtbDogU3dlZXRBbGVydE9wdGlvbnNbJ2h0bWwnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgZm9vdGVyOiBTd2VldEFsZXJ0T3B0aW9uc1snZm9vdGVyJ107XG4gICAgQElucHV0KCkgcHVibGljIHR5cGU6IFN3ZWV0QWxlcnRPcHRpb25zWyd0eXBlJ107XG4gICAgQElucHV0KCkgcHVibGljIGJhY2tkcm9wOiBTd2VldEFsZXJ0T3B0aW9uc1snYmFja2Ryb3AnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgdG9hc3Q6IFN3ZWV0QWxlcnRPcHRpb25zWyd0b2FzdCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyB0YXJnZXQ6IFN3ZWV0QWxlcnRPcHRpb25zWyd0YXJnZXQnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW5wdXQ6IFN3ZWV0QWxlcnRPcHRpb25zWydpbnB1dCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyB3aWR0aDogU3dlZXRBbGVydE9wdGlvbnNbJ3dpZHRoJ107XG4gICAgQElucHV0KCkgcHVibGljIHBhZGRpbmc6IFN3ZWV0QWxlcnRPcHRpb25zWydwYWRkaW5nJ107XG4gICAgQElucHV0KCkgcHVibGljIGJhY2tncm91bmQ6IFN3ZWV0QWxlcnRPcHRpb25zWydiYWNrZ3JvdW5kJ107XG4gICAgQElucHV0KCkgcHVibGljIHBvc2l0aW9uOiBTd2VldEFsZXJ0T3B0aW9uc1sncG9zaXRpb24nXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgZ3JvdzogU3dlZXRBbGVydE9wdGlvbnNbJ2dyb3cnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgY3VzdG9tQ2xhc3M6IFN3ZWV0QWxlcnRPcHRpb25zWydjdXN0b21DbGFzcyddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyB0aW1lcjogU3dlZXRBbGVydE9wdGlvbnNbJ3RpbWVyJ107XG4gICAgQElucHV0KCkgcHVibGljIGFuaW1hdGlvbjogU3dlZXRBbGVydE9wdGlvbnNbJ2FuaW1hdGlvbiddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBhbGxvd091dHNpZGVDbGljazogU3dlZXRBbGVydE9wdGlvbnNbJ2FsbG93T3V0c2lkZUNsaWNrJ107XG4gICAgQElucHV0KCkgcHVibGljIGFsbG93RXNjYXBlS2V5OiBTd2VldEFsZXJ0T3B0aW9uc1snYWxsb3dFc2NhcGVLZXknXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgYWxsb3dFbnRlcktleTogU3dlZXRBbGVydE9wdGlvbnNbJ2FsbG93RW50ZXJLZXknXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgc2hvd0NvbmZpcm1CdXR0b246IFN3ZWV0QWxlcnRPcHRpb25zWydzaG93Q29uZmlybUJ1dHRvbiddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBzaG93Q2FuY2VsQnV0dG9uOiBTd2VldEFsZXJ0T3B0aW9uc1snc2hvd0NhbmNlbEJ1dHRvbiddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjb25maXJtQnV0dG9uVGV4dDogU3dlZXRBbGVydE9wdGlvbnNbJ2NvbmZpcm1CdXR0b25UZXh0J107XG4gICAgQElucHV0KCkgcHVibGljIGNhbmNlbEJ1dHRvblRleHQ6IFN3ZWV0QWxlcnRPcHRpb25zWydjYW5jZWxCdXR0b25UZXh0J107XG4gICAgQElucHV0KCkgcHVibGljIGNvbmZpcm1CdXR0b25Db2xvcjogU3dlZXRBbGVydE9wdGlvbnNbJ2NvbmZpcm1CdXR0b25Db2xvciddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjYW5jZWxCdXR0b25Db2xvcjogU3dlZXRBbGVydE9wdGlvbnNbJ2NhbmNlbEJ1dHRvbkNvbG9yJ107XG4gICAgQElucHV0KCkgcHVibGljIGNvbmZpcm1CdXR0b25DbGFzczogU3dlZXRBbGVydE9wdGlvbnNbJ2NvbmZpcm1CdXR0b25DbGFzcyddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjYW5jZWxCdXR0b25DbGFzczogU3dlZXRBbGVydE9wdGlvbnNbJ2NhbmNlbEJ1dHRvbkNsYXNzJ107XG4gICAgQElucHV0KCkgcHVibGljIGNvbmZpcm1CdXR0b25BcmlhTGFiZWw6IFN3ZWV0QWxlcnRPcHRpb25zWydjb25maXJtQnV0dG9uQXJpYUxhYmVsJ107XG4gICAgQElucHV0KCkgcHVibGljIGNhbmNlbEJ1dHRvbkFyaWFMYWJlbDogU3dlZXRBbGVydE9wdGlvbnNbJ2NhbmNlbEJ1dHRvbkFyaWFMYWJlbCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBidXR0b25zU3R5bGluZzogU3dlZXRBbGVydE9wdGlvbnNbJ2J1dHRvbnNTdHlsaW5nJ107XG4gICAgQElucHV0KCkgcHVibGljIHJldmVyc2VCdXR0b25zOiBTd2VldEFsZXJ0T3B0aW9uc1sncmV2ZXJzZUJ1dHRvbnMnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgZm9jdXNDb25maXJtOiBTd2VldEFsZXJ0T3B0aW9uc1snZm9jdXNDb25maXJtJ107XG4gICAgQElucHV0KCkgcHVibGljIGZvY3VzQ2FuY2VsOiBTd2VldEFsZXJ0T3B0aW9uc1snZm9jdXNDYW5jZWwnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgc2hvd0Nsb3NlQnV0dG9uOiBTd2VldEFsZXJ0T3B0aW9uc1snc2hvd0Nsb3NlQnV0dG9uJ107XG4gICAgQElucHV0KCkgcHVibGljIGNsb3NlQnV0dG9uQXJpYUxhYmVsOiBTd2VldEFsZXJ0T3B0aW9uc1snY2xvc2VCdXR0b25BcmlhTGFiZWwnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgc2hvd0xvYWRlck9uQ29uZmlybTogU3dlZXRBbGVydE9wdGlvbnNbJ3Nob3dMb2FkZXJPbkNvbmZpcm0nXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgcHJlQ29uZmlybTogU3dlZXRBbGVydE9wdGlvbnNbJ3ByZUNvbmZpcm0nXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW1hZ2VVcmw6IFN3ZWV0QWxlcnRPcHRpb25zWydpbWFnZVVybCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbWFnZVdpZHRoOiBTd2VldEFsZXJ0T3B0aW9uc1snaW1hZ2VXaWR0aCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbWFnZUhlaWdodDogU3dlZXRBbGVydE9wdGlvbnNbJ2ltYWdlSGVpZ2h0J107XG4gICAgQElucHV0KCkgcHVibGljIGltYWdlQWx0OiBTd2VldEFsZXJ0T3B0aW9uc1snaW1hZ2VBbHQnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW1hZ2VDbGFzczogU3dlZXRBbGVydE9wdGlvbnNbJ2ltYWdlQ2xhc3MnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW5wdXRQbGFjZWhvbGRlcjogU3dlZXRBbGVydE9wdGlvbnNbJ2lucHV0UGxhY2Vob2xkZXInXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW5wdXRWYWx1ZTogU3dlZXRBbGVydE9wdGlvbnNbJ2lucHV0VmFsdWUnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW5wdXRPcHRpb25zOiBTd2VldEFsZXJ0T3B0aW9uc1snaW5wdXRPcHRpb25zJ107XG4gICAgQElucHV0KCkgcHVibGljIGlucHV0QXV0b1RyaW06IFN3ZWV0QWxlcnRPcHRpb25zWydpbnB1dEF1dG9UcmltJ107XG4gICAgQElucHV0KCkgcHVibGljIGlucHV0QXR0cmlidXRlczogU3dlZXRBbGVydE9wdGlvbnNbJ2lucHV0QXR0cmlidXRlcyddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbnB1dFZhbGlkYXRvcjogU3dlZXRBbGVydE9wdGlvbnNbJ2lucHV0VmFsaWRhdG9yJ107XG4gICAgQElucHV0KCkgcHVibGljIGlucHV0Q2xhc3M6IFN3ZWV0QWxlcnRPcHRpb25zWydpbnB1dENsYXNzJ107XG4gICAgQElucHV0KCkgcHVibGljIHByb2dyZXNzU3RlcHM6IFN3ZWV0QWxlcnRPcHRpb25zWydwcm9ncmVzc1N0ZXBzJ107XG4gICAgQElucHV0KCkgcHVibGljIGN1cnJlbnRQcm9ncmVzc1N0ZXA6IFN3ZWV0QWxlcnRPcHRpb25zWydjdXJyZW50UHJvZ3Jlc3NTdGVwJ107XG4gICAgQElucHV0KCkgcHVibGljIHByb2dyZXNzU3RlcHNEaXN0YW5jZTogU3dlZXRBbGVydE9wdGlvbnNbJ3Byb2dyZXNzU3RlcHNEaXN0YW5jZSddO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHMgYSBCZWZvcmVPcGVuRXZlbnQgd2hlbiB0aGUgbW9kYWwgRE9NIGVsZW1lbnQgaGFzIGJlZW4gY3JlYXRlZC5cbiAgICAgKiBVc2VmdWwgdG8gcGVyZm9ybSBET00gbXV0YXRpb25zIGJlZm9yZSB0aGUgbW9kYWwgaXMgc2hvd24uXG4gICAgICovXG4gICAgQE91dHB1dCgpIHB1YmxpYyByZWFkb25seSBiZWZvcmVPcGVuID0gbmV3IEV2ZW50RW1pdHRlcjxldmVudHMuQmVmb3JlT3BlbkV2ZW50PigpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gT3BlbkV2ZW50IHdoZW4gdGhlIG1vZGFsIGlzIHNob3duLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKSBwdWJsaWMgcmVhZG9ubHkgb3BlbiA9IG5ldyBFdmVudEVtaXR0ZXI8ZXZlbnRzLk9wZW5FdmVudD4oKTtcblxuICAgIC8qKlxuICAgICAqIEVtaXRzIGEgQ2xvc2VFdmVudCB3aGVuIG1vZGFsIGdldCBjbG9zZWQuXG4gICAgICovXG4gICAgQE91dHB1dCgpIHB1YmxpYyByZWFkb25seSBjbG9zZSA9IG5ldyBFdmVudEVtaXR0ZXI8ZXZlbnRzLkNsb3NlRXZlbnQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyB3aGVuIHRoZSB1c2VyIGNsaWNrcyBcIkNvbmZpcm1cIi5cbiAgICAgKiBCZWFycyBhIHZhbHVlIHdoZW4gdXNpbmcgXCJpbnB1dFwiLCByZXNvbHZlZCBcInByZUNvbmZpcm1cIiwgZXRjLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKiAgICAgcHVibGljIGhhbmRsZUNvbmZpcm0oZW1haWw6IHN0cmluZyk6IHZvaWQge1xuICAgICAqICAgICAgICAgLy8gLi4uIHNhdmUgdXNlciBlbWFpbFxuICAgICAqICAgICB9XG4gICAgICovXG4gICAgQE91dHB1dCgpIHB1YmxpYyByZWFkb25seSBjb25maXJtID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyB3aGVuIHRoZSB1c2VyIGNsaWNrcyBcIkNhbmNlbFwiIChvciBkaXNtaXNzZXMgdGhlIG1vZGFsIGJ5IGFueSBvdGhlciB3YXkpLlxuICAgICAqIEJ5IGRlZmF1bHQsIGl0IHdpbGwgZW1pdCBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHJlYXNvbiBmb3Igd2hpY2ggdGhlIFN3ZWV0QWxlcnQgaGFzIGJlZW4gY2xvc2VkLCBvciB0aGVcbiAgICAgKiB2YWx1ZSBvZiBhIHJlamVjdGVkIFwicHJlQ29uZmlybVwiLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKiAgICAgcHVibGljIGhhbmRsZUNhbmNlbChyZWFzb246IHN0cmluZyk6IHZvaWQge1xuICAgICAqICAgICAgICAgLy8gcmVhc29uIGNhbiBiZSAnY2FuY2VsJywgJ292ZXJsYXknLCAnY2xvc2UnLCBhbmQgJ3RpbWVyJ1xuICAgICAqICAgICAgICAgLy8gLi4uIGRvIHNvbWV0aGluZ1xuICAgICAqICAgICB9XG4gICAgICovXG4gICAgQE91dHB1dCgpIHB1YmxpYyByZWFkb25seSBjYW5jZWwgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCBvZiBTd2VldEFsZXJ0MiBuYXRpdmUgb3B0aW9ucywgdXNlZnVsIGlmOlxuICAgICAqICAtIHlvdSBkb24ndCB3YW50IHRvIHVzZSB0aGUgQElucHV0cyBmb3IgcHJhY3RpY2FsL3BoaWxvc29waGljYWwgcmVhc29ucyA7XG4gICAgICogIC0gdGhlcmUgYXJlIG1pc3NpbmcgQElucHV0cyBiZWNhdXNlIG5neC1zd2VldGFsZXJ0MiBpc24ndCB1cC10by1kYXRlIHdpdGggU3dlZXRBbGVydDIncyBsYXRlc3QgY2hhbmdlcy5cbiAgICAgKlxuICAgICAqIC8hXFwgQmUgYXdhcmUgdGhhdCB0aGUgb3B0aW9ucyBkZWZpbmVkIGluIHRoaXMgb2JqZWN0IHdpbGwgb3ZlcnJpZGUgdGhlIEBJbnB1dHMgb2YgdGhlIHNhbWUgbmFtZS5cbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgc2V0IG9wdGlvbnMob3B0aW9uczogU3dlZXRBbGVydE9wdGlvbnMpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucykuZm9yRWFjaCh0aGlzLm1hcmtUb3VjaGVkKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IG9wdGlvbnMoKTogU3dlZXRBbGVydE9wdGlvbnMge1xuICAgICAgICBjb25zdCBvcHRpb25zOiBTd2VldEFsZXJ0T3B0aW9ucyA9IHt9O1xuXG4gICAgICAgIC8vPT4gV2Ugd2lsbCBjb21wdXRlIHRoZSBvcHRpb25zIG9iamVjdCBiYXNlZCBvbiB0aGUgb3B0aW9uIGtleXMgdGhhdCBhcmUga25vd24gdG8gaGF2ZSBjaGFuZ2VkLlxuICAgICAgICAvLyBUaGF0IGF2b2lkcyBwYXNzaW5nIGEgZ2lnYW50aWMgb2JqZWN0IHRvIFN3ZWV0QWxlcnQyLCBtYWtpbmcgZGVidWdnaW5nIGVhc2llciBhbmQgcG90ZW50aWFsbHkgYXZvaWRpbmdcbiAgICAgICAgLy8gc2lkZSBlZmZlY3RzLlxuICAgICAgICB0aGlzLnRvdWNoZWRQcm9wcy5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgICAgICAgb3B0aW9uc1twcm9wXSA9ICh0aGlzIGFzIHsgW3Byb3A6IHN0cmluZ106IGFueSB9KVtwcm9wXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuXG4gICAgcHVibGljIG5hdGl2ZVN3YWwgPSBTd2FsO1xuXG4gICAgcHJpdmF0ZSBpc0N1cnJlbnRseVNob3duID0gZmFsc2U7XG5cbiAgICBwcml2YXRlIHJlYWRvbmx5IHRvdWNoZWRQcm9wcyA9IG5ldyBTZXQ8a2V5b2YgU3dlZXRBbGVydE9wdGlvbnM+KCk7XG5cbiAgICBwcml2YXRlIHJlYWRvbmx5IG1hcmtUb3VjaGVkID0gdGhpcy50b3VjaGVkUHJvcHMuYWRkLmJpbmQodGhpcy50b3VjaGVkUHJvcHMpO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKEBJbmplY3QoU3dhbERlZmF1bHRzKSBwcml2YXRlIHJlYWRvbmx5IGRlZmF1bHRTd2FsT3B0aW9uczogU3dlZXRBbGVydE9wdGlvbnMpIHtcbiAgICAgICAgLy89PiBGb3JjZSBgdGhpc2Agc2NvcGUgb2Ygc2hvdygpIG9uIHRoaXMgY29tcG9uZW50XG4gICAgICAgIC8vICAgVXNlZnVsIGZvciBkb2luZyB0aGluZ3MgbGlrZSAoY2xpY2spPVwibXlTd2FsLnNob3coKVwiLlxuICAgICAgICB0aGlzLnNob3cgPSB0aGlzLnNob3cuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICAgICAgICBPYmplY3Qua2V5cyhjaGFuZ2VzKVxuICAgICAgICAgICAgLmZpbHRlcihwcm9wID0+IHByb3AgIT09ICdvcHRpb25zJylcbiAgICAgICAgICAgIC5mb3JFYWNoKHRoaXMubWFya1RvdWNoZWQpO1xuICAgIH1cblxuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDdXJyZW50bHlTaG93bikge1xuICAgICAgICAgICAgU3dhbC5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2hvd3MgdGhlIFN3ZWV0QWxlcnQuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIHRoZSBTd2VldEFsZXJ0MiBwcm9taXNlIGZvciBjb252ZW5pZW5jZSBhbmQgdXNlIGluIGNvZGUgYmVoaW5kIHRlbXBsYXRlcy5cbiAgICAgKiBPdGhlcndpc2UsIChjb25maXJtKT1cIm15SGFuZGxlcigkZXZlbnQpXCIgYW5kIChjYW5jZWwpPVwibXlIYW5kbGVyKCRldmVudClcIiBjYW4gYmUgdXNlZCBpbiB0ZW1wbGF0ZXMuXG4gICAgICovXG4gICAgcHVibGljIHNob3coKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgICAgLy89PiBCdWlsZCB0aGUgU3dlZXRBbGVydDIgb3B0aW9uc1xuICAgICAgICBjb25zdCBvcHRpb25zOiBTd2VldEFsZXJ0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIC8vPT4gTWVyZ2Ugd2l0aCB0aGUgZGVmYXVsdCBtb2R1bGUtbGV2ZWwgb3B0aW9uc1xuICAgICAgICAgICAgLi4udGhpcy5kZWZhdWx0U3dhbE9wdGlvbnMsXG5cbiAgICAgICAgICAgIC8vPT4gTWVyZ2Ugd2l0aCBjYWxjdWxhdGVkIG9wdGlvbnMgc2V0IGZvciB0aGF0IHNwZWNpZmljIHN3YWxcbiAgICAgICAgICAgIC4uLnRoaXMub3B0aW9ucyxcblxuICAgICAgICAgICAgLy89PiBIYW5kbGUgbW9kYWwgbGlmZWN5Y2xlIGV2ZW50c1xuICAgICAgICAgICAgb25CZWZvcmVPcGVuOiAobW9kYWxFbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5iZWZvcmVPcGVuLmVtaXQoeyBtb2RhbEVsZW1lbnQgfSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBvbk9wZW46IChtb2RhbEVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzQ3VycmVudGx5U2hvd24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMub3Blbi5lbWl0KHsgbW9kYWxFbGVtZW50IH0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgb25DbG9zZTogKG1vZGFsRWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNDdXJyZW50bHlTaG93biA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UuZW1pdCh7IG1vZGFsRWxlbWVudCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLz0+IFNob3cgdGhlIFN3YWwhXG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBTd2FsLmZpcmUob3B0aW9ucyk7XG5cbiAgICAgICAgLy89PiBIYW5kbGUgKGNvbmZpcm0pIGFuZCAoY2FuY2VsKSBAT3V0cHV0c1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tc3RyaW5nLWxpdGVyYWxcbiAgICAgICAgY29uc3QgdXNlUmVqZWN0aW9ucyA9IChvcHRpb25zIGFzIHsgdXNlUmVqZWN0aW9ucz86IGJvb2xlYW4gfSkudXNlUmVqZWN0aW9ucztcblxuICAgICAgICBwcm9taXNlLnRoZW4oXG4gICAgICAgICAgICByZXN1bHQgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh1c2VSZWplY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlybS5lbWl0KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgndmFsdWUnIGluIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpcm0uZW1pdChyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsLmVtaXQocmVzdWx0LmRpc21pc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnIgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh1c2VSZWplY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsLmVtaXQoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgLy89PiBSZXR1cm4gdGhlIHVuYWx0ZXJlZCBwcm9taXNlXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbn1cbiIsImltcG9ydCB7XG4gICAgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBDb21wb25lbnRSZWYsIERpcmVjdGl2ZSwgRXZlbnRFbWl0dGVyLCBIb3N0TGlzdGVuZXIsIElucHV0LCBPbkRlc3Ryb3ksIE9uSW5pdCwgT3V0cHV0LFxuICAgIFZpZXdDb250YWluZXJSZWZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgU3dhbCwgeyBTd2VldEFsZXJ0QXJyYXlPcHRpb25zLCBTd2VldEFsZXJ0T3B0aW9ucyB9IGZyb20gJ3N3ZWV0YWxlcnQyJztcbmltcG9ydCB7IFN3YWxDb21wb25lbnQgfSBmcm9tICcuL3N3YWwuY29tcG9uZW50JztcblxuLyoqXG4gKiBbc3dhbF0gZGlyZWN0aXZlLiBJdCB0YWtlcyBhIHZhbHVlIHRoYXQgZGVmaW5lcyB0aGUgU3dlZXQgQWxlcnQgYW5kIGNhbiBiZSBvZiB0aHJlZSB0eXBlczpcbiAqXG4gKiAxKSBBIHNpbXBsZSBhcnJheSBvZiB0d28gb3IgdGhyZWUgc3RyaW5ncyBkZWZpbmluZyBbdGl0bGUsIHRleHQsIHR5cGVdIC0gdGhlIHR5cGUgYmVpbmcgb3B0aW9uYWwsIGV4OlxuICpcbiAqICAgIDxidXR0b24gW3N3YWxdPVwiWydUaXRsZScsICdUZXh0J11cIj5DbGljayBtZTwvYnV0dG9uPlxuICpcbiAqIDIpIEEgbmF0aXZlIFN3ZWV0QWxlcnQyIG9wdGlvbnMgb2JqZWN0LCBleDpcbiAqXG4gKiAgICA8YnV0dG9uIFtzd2FsXT1cInsgdGl0bGU6ICdUaXRsZScsIHRleHQ6ICdUZXh0JyB9XCI+Q2xpY2sgbWU8L2J1dHRvbj5cbiAqXG4gKiAzKSBBIHJlZmVyZW5jZSB0byBhbiBleGlzdGluZyBTd2FsQ29tcG9uZW50IGluc3RhbmNlIGZvciBtb3JlIGFkdmFuY2VkIHVzZXMsIGV4OlxuICpcbiAqICAgIDxidXR0b24gW3N3YWxdPVwibXlTd2FsXCI+Q2xpY2sgbWU8L2J1dHRvbj5cbiAqICAgIDxzd2FsICNteVN3YWwgdGl0bGU9XCJUaXRsZVwiIHRleHQ9XCJUZXh0XCI+PC9zd2FsPlxuICovXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1tzd2FsXSdcbn0pXG5leHBvcnQgY2xhc3MgU3dhbERpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcbiAgICAvKipcbiAgICAgKiBTd2VldEFsZXJ0MiBvcHRpb25zIG9yIGEgU3dhbENvbXBvbmVudCBpbnN0YW5jZS5cbiAgICAgKiBTZWUgdGhlIGNsYXNzIGRvYyBibG9jayBmb3IgbW9yZSBpbmZvcm1hdGlvbnMuXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIHNldCBzd2FsKG9wdGlvbnM6IFN3YWxDb21wb25lbnQgfCBTd2VldEFsZXJ0T3B0aW9ucyB8IFN3ZWV0QWxlcnRBcnJheU9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBTd2FsQ29tcG9uZW50KSB7XG4gICAgICAgICAgICB0aGlzLnN3YWxJbnN0YW5jZSA9IG9wdGlvbnM7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgICAgICAgdGhpcy5zd2FsT3B0aW9ucyA9IFN3YWwuYXJnc1RvUGFyYW1zKG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zd2FsT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyB3aGVuIHRoZSB1c2VyIGNsaWNrcyBcIkNvbmZpcm1cIi5cbiAgICAgKiBCZWFycyBhIHZhbHVlIHdoZW4gdXNpbmcgXCJpbnB1dFwiLCByZXNvbHZlZCBcInByZUNvbmZpcm1cIiwgZXRjLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKiAgICAgcHVibGljIGhhbmRsZUNvbmZpcm0oZW1haWw6IHN0cmluZyk6IHZvaWQge1xuICAgICAqICAgICAgICAgLy8gLi4uIHNhdmUgdXNlciBlbWFpbFxuICAgICAqICAgICB9XG4gICAgICovXG4gICAgQE91dHB1dCgpIHB1YmxpYyByZWFkb25seSBjb25maXJtID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyB3aGVuIHRoZSB1c2VyIGNsaWNrcyBcIkNhbmNlbFwiIChvciBkaXNtaXNzZXMgdGhlIG1vZGFsIGJ5IGFueSBvdGhlciB3YXkpLlxuICAgICAqIEJ5IGRlZmF1bHQsIGl0IHdpbGwgZW1pdCBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHJlYXNvbiBmb3Igd2hpY2ggdGhlIFN3ZWV0QWxlcnQgaGFzIGJlZW4gY2xvc2VkLCBvciB0aGVcbiAgICAgKiB2YWx1ZSBvZiBhIHJlamVjdGVkIFwicHJlQ29uZmlybVwiLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKiAgICAgcHVibGljIGhhbmRsZUNhbmNlbChyZWFzb246IHN0cmluZyk6IHZvaWQge1xuICAgICAqICAgICAgICAgLy8gcmVhc29uIGNhbiBiZSAnY2FuY2VsJywgJ292ZXJsYXknLCAnY2xvc2UnLCBhbmQgJ3RpbWVyJ1xuICAgICAqICAgICAgICAgLy8gLi4uIGRvIHNvbWV0aGluZ1xuICAgICAqICAgICB9XG4gICAgICovXG4gICAgQE91dHB1dCgpIHB1YmxpYyByZWFkb25seSBjYW5jZWwgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlIHVzZXIgZG9lcyBub3QgcHJvdmlkZXMgYSBTd2FsQ29tcG9uZW50IGluc3RhbmNlLCB3ZSBjcmVhdGUgaXQgb24tdGhlLWZseSBhbmQgYXNzaWduIHRoZSBwbGFpbi1vYmplY3RcbiAgICAgKiBvcHRpb25zIHRvIGl0LlxuICAgICAqIFRoaXMgZmllbGRzIGtlZXBzIGEgcmVmZXJlbmNlIHRvIHRoZSBkeW5hbWljYWxseS1jcmVhdGVkIDxzd2FsPiwgdG8gZGVzdHJveSBpdCBhbG9uZyB0aGlzIGRpcmVjdGl2ZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBwcml2YXRlIHN3YWxSZWY6IENvbXBvbmVudFJlZjxTd2FsQ29tcG9uZW50PjtcblxuICAgIC8qKlxuICAgICAqIEFuIGluc3RhbmNlIG9mIHRoZSA8c3dhbD4gY29tcG9uZW50IHRoYXQgdGhpcyBkaXJlY3RpdmUgY29udHJvbHMuXG4gICAgICogQ291bGQgYmUgYW4gaW5zdGFuY2UgcGFzc2VkIGJ5IHRoZSB1c2VyLCBvdGhlcndpc2UgaXQncyB0aGUgaW5zdGFuY2Ugd2UndmUgZHluYW1pY2FsbHkgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBwcml2YXRlIHN3YWxJbnN0YW5jZTogU3dhbENvbXBvbmVudDtcblxuICAgIC8qKlxuICAgICAqIEhvbGRzIHRoZSBuYXRpdmUgU3dlZXRBbGVydDIgb3B0aW9ucy5cbiAgICAgKiBFbXB0eSB3aGVuIHRoZSB1c2VyIHBhc3NlZCBhbiBleGlzdGluZyBTd2FsQ29tcG9uZW50IGluc3RhbmNlLlxuICAgICAqL1xuICAgIHByaXZhdGUgc3dhbE9wdGlvbnM6IFN3ZWV0QWxlcnRPcHRpb25zO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IHZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYsXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgcmVzb2x2ZXI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcikge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9uSW5pdCBsaWZlY3ljbGUgaGFuZGxlci5cbiAgICAgKiBDcmVhdGVzIGEgU3dhbENvbXBvbmVudCBpbnN0YW5jZSBpZiB0aGUgdXNlciBkaWRuJ3QgcHJvdmlkZWQgb25lIGFuZCBiaW5kcyBvbiB0aGF0IGNvbXBvbmVudCAoY29uZmlybSkgYW5kXG4gICAgICogKGNhbmNlbCkgb3V0cHV0cyB0byByZWVtaXQgb24gdGhlIGRpcmVjdGl2ZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5zd2FsSW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGZhY3RvcnkgPSB0aGlzLnJlc29sdmVyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KFN3YWxDb21wb25lbnQpO1xuXG4gICAgICAgICAgICB0aGlzLnN3YWxSZWYgPSB0aGlzLnZpZXdDb250YWluZXJSZWYuY3JlYXRlQ29tcG9uZW50KGZhY3RvcnkpO1xuICAgICAgICAgICAgdGhpcy5zd2FsSW5zdGFuY2UgPSB0aGlzLnN3YWxSZWYuaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPbkRlc3Ryb3kgbGlmZWN5Y2xlIGhhbmRsZXIuXG4gICAgICogRGVzdHJveXMgdGhlIGR5bmFtaWNhbGx5LWNyZWF0ZWQgU3dhbENvbXBvbmVudCBhbmQgdW5zdWJzY3JpYmVzIGZyb20gdGhhdCBjb21wb25lbnQncyAoY29uZmlybSkgYW5kIChjYW5jZWwpLlxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuc3dhbFJlZikge1xuICAgICAgICAgICAgdGhpcy5zd2FsUmVmLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsaWNrIGhhbmRsZXIuXG4gICAgICogVGhlIGRpcmVjdGl2ZSBsaXN0ZW5zIGZvciBvbmNsaWNrIGV2ZW50cyBvbiBpdHMgaG9zdCBlbGVtZW50LlxuICAgICAqIFdoZW4gdGhpcyBoYXBwZW5zLCBpdCBzaG93cyB0aGUgPHN3YWw+IGF0dGFjaGVkIHRvIHRoaXMgZGlyZWN0aXZlLlxuICAgICAqL1xuICAgIEBIb3N0TGlzdGVuZXIoJ2NsaWNrJywgWyckZXZlbnQnXSlcbiAgICBwdWJsaWMgb25Ib3N0Q2xpY2tlZChldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuc3dhbE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc3dhbEluc3RhbmNlLm9wdGlvbnMgPSB0aGlzLnN3YWxPcHRpb25zO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29uZmlybVN1YiA9IHRoaXMuc3dhbEluc3RhbmNlLmNvbmZpcm0uYXNPYnNlcnZhYmxlKCkuc3Vic2NyaWJlKHYgPT4gdGhpcy5jb25maXJtLmVtaXQodikpO1xuICAgICAgICBjb25zdCBjYW5jZWxTdWIgPSB0aGlzLnN3YWxJbnN0YW5jZS5jYW5jZWwuYXNPYnNlcnZhYmxlKCkuc3Vic2NyaWJlKHYgPT4gdGhpcy5jYW5jZWwuZW1pdCh2KSk7XG5cbiAgICAgICAgdGhpcy5zd2FsSW5zdGFuY2Uuc2hvdygpLnRoZW4odW5zdWJzY3JpYmUpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICAgICAgY29uZmlybVN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgY2FuY2VsU3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tcG9uZW50LCBJbnB1dCwgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEhvbGRzIGEgY29uc3VtZXIncyBBbmd1bGFyIHRlbXBsYXRlIGFuZCBkaXNwbGF5cyBpdCBvbiBhIFN3ZWV0IEFsZXJ0LlxuICogU2VlIFN3YWxQYXJ0aWFsRGlyZWN0aXZlIGZvciBpbmZvIGFib3V0IHRoZSBjb3ZlcmVkIGZlYXR1cmUuXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cInRlbXBsYXRlXCI+PC9uZy1jb250YWluZXI+JyxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBTd2FsUGFydGlhbENvbXBvbmVudCB7XG4gICAgQElucHV0KCkgcHVibGljIHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xufVxuIiwiaW1wb3J0IHtcbiAgICBBcHBsaWNhdGlvblJlZiwgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBDb21wb25lbnRSZWYsIERpcmVjdGl2ZSwgSG9zdCwgSW5qZWN0b3IsIElucHV0LCBPbkRlc3Ryb3ksIE9uSW5pdCxcbiAgICBUZW1wbGF0ZVJlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgU3dhbFBhcnRpYWxUYXJnZXRzIH0gZnJvbSAnLi9zd2FsLXBhcnRpYWwtdGFyZ2V0cyc7XG5pbXBvcnQgeyBTd2FsUGFydGlhbENvbXBvbmVudCB9IGZyb20gJy4vc3dhbC1wYXJ0aWFsLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBTd2FsQ29tcG9uZW50IH0gZnJvbSAnLi9zd2FsLmNvbXBvbmVudCc7XG5cbi8qKlxuICogQSBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZSB0aGF0IGxldHMgeW91IHVzZSBBbmd1bGFyIHRlbXBsYXRlcyBpbnNpZGUgb2YgU3dlZXQgQWxlcnRzLlxuICogVGhlcmUgYXJlIGRpZmZlcmVudCB0YXJnZXRhYmxlIHpvbmVzIGluIGEgU3dlZXQgQWxlcnQ6IHRpdGxlLCBjb250ZW50LCBjb25maXJtQnV0dG9uLCBjYW5jZWxCdXR0b24sIGJ1dHRvbnNXcmFwcGVyLlxuICogVGhlIGRlZmF1bHQgdGFyZ2V0IGlzIHRoZSBjb250ZW50IHpvbmUuXG4gKlxuICogVXNhZ2UgaW4geW91ciBjb21wb25lbnQncyBUeXBlU2NyaXB0IGNvZGUtYmVoaW5kIChpZiB5b3UgdXNlIGFub3RoZXIgdGFyZ2V0IHRoYW4gXCJjb250ZW50XCIpOlxuICpcbiAqICAgICBAQ29tcG9uZW50KHsgLi4uIH0pXG4gKiAgICAgZXhwb3J0IGNsYXNzIE15Q29tcG9uZW50IHtcbiAqICAgICAgICAgcHVibGljIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSBzd2FsVGFyZ2V0czogU3dhbFBhcnRpYWxUYXJnZXRzKSB7XG4gKiAgICAgICAgIH1cbiAqICAgICB9XG4gKlxuICogVXNhZ2UgaW4gdGhlIHRlbXBsYXRlOlxuICpcbiAqICAgICA8c3dhbCB0aXRsZT1cIkZpbGwgdGhlIGZvcm1cIiAoY29uZmlybSk9XCJjb25maXJtSGFuZGxlcigpXCI+XG4gKiAgICAgICAgIDwhLS0gVGhpcyBmb3JtIHdpbGwgYmUgZGlzcGxheWVkIGFzIHRoZSBhbGVydCBtYWluIGNvbnRlbnRcbiAqICAgICAgICAgICAgICBUYXJnZXRzIHRoZSBhbGVydCdzIG1haW4gY29udGVudCB6b25lIGJ5IGRlZmF1bHQgLS0+XG4gKiAgICAgICAgIDxmb3JtICpzd2FsUGFydGlhbCBbZm9ybUNvbnRyb2xdPVwibXlGb3JtXCI+XG4gKiAgICAgICAgICAgICAuLi5cbiAqICAgICAgICAgPC9mb3JtPlxuICpcbiAqICAgICAgICAgPCEtLSBUaGlzIHRhcmdldHMgdGhlIGNvbmZpcm0gYnV0dG9uJ3MgaW5uZXIgY29udGVudFxuICogICAgICAgICAgICAgIE5vdGljZSB0aGUgdXNhZ2Ugb2YgbmctY29udGFpbmVyIHRvIGF2b2lkIGNyZWF0aW5nIGFuIHVzZWxlc3MgRE9NIGVsZW1lbnQgaW5zaWRlIHRoZSBidXR0b24gLS0+XG4gKiAgICAgICAgIDxuZy1jb250YWluZXIgKnN3YWxQYXJ0aWFsPVwic3dhbFRhcmdldHMuY29uZmlybUJ1dHRvblwiPlxuICogICAgICAgICAgICAgIFNlbmQgKHt7IHNlY29uZHNMZWZ0IH19IHNlY29uZHMgbGVmdClcbiAqICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gKiAgICAgPHN3YWw+XG4gKi9cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3N3YWxQYXJ0aWFsXSdcbn0pXG5leHBvcnQgY2xhc3MgU3dhbFBhcnRpYWxEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG4gICAgLyoqXG4gICAgICogVGFrZXMgYSBcInBhcnRpYWwgdGFyZ2V0XCIgb3Igbm90aGluZyAod2lsbCB0YXJnZXQgbWFpbiBjb250ZW50IHpvbmUgYnkgZGVmYXVsdCkuXG4gICAgICpcbiAgICAgKiBTZWUgdGhlIHtAbGluayBTd2FsUGFydGlhbFRhcmdldHN9IHNlcnZpY2UgdG8gc2VlIHRoZSBhdmFpbGFibGUgdGFyZ2V0cy5cbiAgICAgKiBTZWUgdGhlIGNsYXNzIGRvYyBibG9jayBmb3IgbW9yZSBpbmZvcm1hdGlvbnMuXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIHN3YWxQYXJ0aWFsOiAoKSA9PiBIVE1MRWxlbWVudDtcblxuICAgIC8qKlxuICAgICAqIEhvbGRzIHRoZSBjb21wb25lbnQgcmVmZXJlbmNlIG9mIHRoZSBjb250cm9sbGVkIFN3YWxQYXJ0aWFsQ29tcG9uZW50IHRvIGRlc3Ryb3kgaXQgd2hlbiBubyBsb25nZXIgbmVlZGVkLlxuICAgICAqL1xuICAgIHByaXZhdGUgcGFydGlhbFJlZjogQ29tcG9uZW50UmVmPFN3YWxQYXJ0aWFsQ29tcG9uZW50PjtcblxuICAgIHByaXZhdGUgYmVmb3JlT3BlblN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuICAgIHByaXZhdGUgY2xvc2VTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IHJlc29sdmVyOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgaW5qZWN0b3I6IEluamVjdG9yLFxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IGFwcDogQXBwbGljYXRpb25SZWYsXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgdGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT4sXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgc3dhbFRhcmdldHM6IFN3YWxQYXJ0aWFsVGFyZ2V0cyxcbiAgICAgICAgQEhvc3QoKSBwcml2YXRlIHJlYWRvbmx5IHN3YWxDb21wb25lbnQ6IFN3YWxDb21wb25lbnQpIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVzIHRvIHRoZSB0aGUgU3dlZXQgQWxlcnQgYXBwZWFyYW5jZS9kaXNhcHBlYXJhbmNlIHRvIGNyZWF0ZS9kZXN0cm95IHRoZSBTd2FsUGFydGlhbENvbXBvbmVudCB0aGF0IHdpbGxcbiAgICAgKiByZWNlaXZlIHRoZSBjb25zdW1lcidzIHRlbXBsYXRlLlxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5iZWZvcmVPcGVuU3Vic2NyaXB0aW9uID0gdGhpcy5zd2FsQ29tcG9uZW50LmJlZm9yZU9wZW4uYXNPYnNlcnZhYmxlKCkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIC8vPT4gQ3JlYXRlIHRoZSBTd2FsUGFydGlhbENvbXBvbmVudCBvbiB0aGUgdGFyZ2V0IERPTSBub2RlIGluIHRoZSBTd2VldCBBbGVydFxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0RWwgPSB0aGlzLnN3YWxQYXJ0aWFsID8gdGhpcy5zd2FsUGFydGlhbCgpIDogdGhpcy5zd2FsVGFyZ2V0cy5jb250ZW50KCk7XG4gICAgICAgICAgICBjb25zdCBmYWN0b3J5ID0gdGhpcy5yZXNvbHZlci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShTd2FsUGFydGlhbENvbXBvbmVudCk7XG5cbiAgICAgICAgICAgIHRoaXMucGFydGlhbFJlZiA9IGZhY3RvcnkuY3JlYXRlKHRoaXMuaW5qZWN0b3IsIFtdLCB0YXJnZXRFbCk7XG5cbiAgICAgICAgICAgIC8vPT4gQXBwbHkgdGhlIGNvbnN1bWVyJ3MgdGVtcGxhdGUgb24gdGhlIGNvbXBvbmVudFxuICAgICAgICAgICAgdGhpcy5wYXJ0aWFsUmVmLmluc3RhbmNlLnRlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZVJlZjtcblxuICAgICAgICAgICAgLy89PiBNYWtlIHRoZSBBbmd1bGFyIGFwcCBhd2FyZSBvZiB0aGF0IGRldGFjaGVkIHZpZXcgc28gY2hhbmdlIGRldGVjdGlvbiB3b3Jrc1xuICAgICAgICAgICAgdGhpcy5hcHAuYXR0YWNoVmlldyh0aGlzLnBhcnRpYWxSZWYuaG9zdFZpZXcpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmNsb3NlU3Vic2NyaXB0aW9uID0gdGhpcy5zd2FsQ29tcG9uZW50LmNsb3NlLmFzT2JzZXJ2YWJsZSgpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAvLz0+IERldGFjaCB0aGUgcGFydGlhbCBjb21wb25lbnQgZnJvbSB0aGUgYXBwIGFuZCBkZXN0cm95IGl0XG4gICAgICAgICAgICB0aGlzLmFwcC5kZXRhY2hWaWV3KHRoaXMucGFydGlhbFJlZi5ob3N0Vmlldyk7XG4gICAgICAgICAgICB0aGlzLnBhcnRpYWxSZWYuZGVzdHJveSgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVbnN1YnNjcmliZXMgZnJvbSB0aGUgU3dlZXQgQWxlcnQgYXBwZWFyYW5jZS9kaXNhcHBlYXJhbmNlLlxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5iZWZvcmVPcGVuU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuY2xvc2VTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTW9kdWxlV2l0aFByb3ZpZGVycywgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN3ZWV0QWxlcnRPcHRpb25zIH0gZnJvbSAnc3dlZXRhbGVydDInO1xuaW1wb3J0IHsgc3dhbERlZmF1bHRzUHJvdmlkZXIgfSBmcm9tICcuL2RpJztcbmltcG9ydCB7IFN3YWxQYXJ0aWFsVGFyZ2V0cyB9IGZyb20gJy4vc3dhbC1wYXJ0aWFsLXRhcmdldHMnO1xuaW1wb3J0IHsgU3dhbFBhcnRpYWxDb21wb25lbnQgfSBmcm9tICcuL3N3YWwtcGFydGlhbC5jb21wb25lbnQnO1xuaW1wb3J0IHsgU3dhbFBhcnRpYWxEaXJlY3RpdmUgfSBmcm9tICcuL3N3YWwtcGFydGlhbC5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgU3dhbENvbXBvbmVudCB9IGZyb20gJy4vc3dhbC5jb21wb25lbnQnO1xuaW1wb3J0IHsgU3dhbERpcmVjdGl2ZSB9IGZyb20gJy4vc3dhbC5kaXJlY3RpdmUnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBTd2FsQ29tcG9uZW50LCBTd2FsUGFydGlhbERpcmVjdGl2ZSwgU3dhbFBhcnRpYWxDb21wb25lbnQsXG4gICAgICAgIFN3YWxEaXJlY3RpdmVcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICBTd2FsUGFydGlhbFRhcmdldHNcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIFN3YWxDb21wb25lbnQsIFN3YWxQYXJ0aWFsRGlyZWN0aXZlLFxuICAgICAgICBTd2FsRGlyZWN0aXZlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgU3dhbENvbXBvbmVudCwgU3dhbFBhcnRpYWxDb21wb25lbnRcbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIFN3ZWV0QWxlcnQyTW9kdWxlIHtcbiAgICBwdWJsaWMgc3RhdGljIGZvclJvb3QoZGVmYXVsdFN3YWxPcHRpb25zPzogU3dlZXRBbGVydE9wdGlvbnMpOiBNb2R1bGVXaXRoUHJvdmlkZXJzIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBTd2VldEFsZXJ0Mk1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW3N3YWxEZWZhdWx0c1Byb3ZpZGVyKGRlZmF1bHRTd2FsT3B0aW9ucyldXG4gICAgICAgIH07XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOzs7OztBQU9BOzs7Ozs7SUFBQTtRQUNvQixVQUFLLEdBQUcsY0FBTSxPQUFBLElBQUksQ0FBQyxRQUFRLEVBQUUsR0FBQSxDQUFDO1FBRTlCLFlBQU8sR0FBRyxjQUFNLE9BQUEsSUFBSSxDQUFDLFVBQVUsRUFBRSxHQUFBLENBQUM7UUFFbEMsWUFBTyxHQUFHLGNBQU0sT0FBQSxJQUFJLENBQUMsVUFBVSxFQUFFLEdBQUEsQ0FBQztRQUVsQyxrQkFBYSxHQUFHLGNBQU0sT0FBQSxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsR0FB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