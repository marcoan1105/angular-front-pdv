import Swal from 'sweetalert2';
import { InjectionToken, ChangeDetectionStrategy, Component, EventEmitter, Inject, Input, Output, ComponentFactoryResolver, Directive, HostListener, ViewContainerRef, TemplateRef, ApplicationRef, Host, Injector, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Represents an object of targets for <swal> partials (use with *swalPartial directive).
 * We must use thunks to access the Swal.* functions listed below, because they get created after the first modal is
 * shown, so this object lets us reference those functions safely and in a statically-typed manner.
 */
class SwalPartialTargets {
    constructor() {
        this.title = () => Swal.getTitle();
        this.content = () => Swal.getContent();
        this.actions = () => Swal.getActions();
        this.confirmButton = () => Swal.getConfirmButton();
        this.cancelButton = () => Swal.getCancelButton();
        this.footer = () => Swal.getFooter();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const SwalDefaults = new InjectionToken('SwalDefaults');
/**
 * @param {?=} options
 * @return {?}
 */
function swalDefaultsProvider(options = {}) {
    return {
        provide: SwalDefaults,
        useValue: options
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * <swal> component. See the README.md for usage.
 *
 * It contains a bunch of \@Inputs that have a perfect 1:1 mapping with SweetAlert2 options.
 * Their types are directly coming from SweetAlert2 types defintitions, meaning that ngx-sweetalert2 is tightly coupled
 * to SweetAlert2, but also is type-safe.
 *
 * /!\ Some SweetAlert options aren't \@Inputs but \@Outputs: onBeforeOpen, onOpen, and onClose (without "on*" prefix).
 *     However, preConfirm and inputValidtor are still \@Inputs because there are not event handlers, there can't be
 *     multiple listeners and we need the Promise they must return.
 *
 * /!\ You can notice that the SweetAlert2 `useRejections` and `expectRejections` are the only one to not have
 *     an \@Input(). That's because they are deprecated and not using the default value of these parameters leads to
 *     clunky control flow. They are supported (use [options]="{}"), but please don't use them.
 */
class SwalComponent {
    /**
     * @param {?} defaultSwalOptions
     */
    constructor(defaultSwalOptions) {
        this.defaultSwalOptions = defaultSwalOptions;
        /**
         * Emits a BeforeOpenEvent when the modal DOM element has been created.
         * Useful to perform DOM mutations before the modal is shown.
         */
        this.beforeOpen = new EventEmitter();
        /**
         * Emits an OpenEvent when the modal is shown.
         */
        this.open = new EventEmitter();
        /**
         * Emits a CloseEvent when modal get closed.
         */
        this.close = new EventEmitter();
        /**
         * Emits when the user clicks "Confirm".
         * Bears a value when using "input", resolved "preConfirm", etc.
         *
         * Example:
         *     public handleConfirm(email: string): void {
         *         // ... save user email
         *     }
         */
        this.confirm = new EventEmitter();
        /**
         * Emits when the user clicks "Cancel" (or dismisses the modal by any other way).
         * By default, it will emit a string representing the reason for which the SweetAlert has been closed, or the
         * value of a rejected "preConfirm".
         *
         * Example:
         *     public handleCancel(reason: string): void {
         *         // reason can be 'cancel', 'overlay', 'close', and 'timer'
         *         // ... do something
         *     }
         */
        this.cancel = new EventEmitter();
        this.nativeSwal = Swal;
        this.isCurrentlyShown = false;
        this.touchedProps = new Set();
        this.markTouched = this.touchedProps.add.bind(this.touchedProps);
        //=> Force `this` scope of show() on this component
        //   Useful for doing things like (click)="mySwal.show()".
        this.show = this.show.bind(this);
    }
    /**
     * An object of SweetAlert2 native options, useful if:
     *  - you don't want to use the \@Inputs for practical/philosophical reasons ;
     *  - there are missing \@Inputs because ngx-sweetalert2 isn't up-to-date with SweetAlert2's latest changes.
     *
     * /!\ Be aware that the options defined in this object will override the \@Inputs of the same name.
     * @param {?} options
     * @return {?}
     */
    set options(options) {
        Object.assign(this, options);
        Object.keys(options).forEach(this.markTouched);
    }
    /**
     * @return {?}
     */
    get options() {
        /** @type {?} */
        const options = {};
        //=> We will compute the options object based on the option keys that are known to have changed.
        // That avoids passing a gigantic object to SweetAlert2, making debugging easier and potentially avoiding
        // side effects.
        this.touchedProps.forEach(prop => {
            options[prop] = ((/** @type {?} */ (this)))[prop];
        });
        return options;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        Object.keys(changes)
            .filter(prop => prop !== 'options')
            .forEach(this.markTouched);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.isCurrentlyShown) {
            Swal.close();
        }
    }
    /**
     * Shows the SweetAlert.
     *
     * Returns the SweetAlert2 promise for convenience and use in code behind templates.
     * Otherwise, (confirm)="myHandler($event)" and (cancel)="myHandler($event)" can be used in templates.
     * @return {?}
     */
    show() {
        //=> Build the SweetAlert2 options
        /** @type {?} */
        const options = Object.assign({}, this.defaultSwalOptions, this.options, { onBeforeOpen: (modalElement) => {
                this.beforeOpen.emit({ modalElement });
            }, onOpen: (modalElement) => {
                this.isCurrentlyShown = true;
                this.open.emit({ modalElement });
            }, onClose: (modalElement) => {
                this.isCurrentlyShown = false;
                this.close.emit({ modalElement });
            } });
        //=> Show the Swal!
        /** @type {?} */
        const promise = Swal.fire(options);
        //=> Handle (confirm) and (cancel) @Outputs
        // tslint:disable-next-line:no-string-literal
        /** @type {?} */
        const useRejections = ((/** @type {?} */ (options))).useRejections;
        promise.then(result => {
            if (useRejections) {
                this.confirm.emit(result);
            }
            else if ('value' in result) {
                this.confirm.emit(result.value);
            }
            else {
                this.cancel.emit(result.dismiss);
            }
        }, err => {
            if (useRejections) {
                this.cancel.emit(err);
            }
        });
        //=> Return the unaltered promise
        return promise;
    }
}
SwalComponent.decorators = [
    { type: Component, args: [{
                selector: 'swal',
                template: '',
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
SwalComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [SwalDefaults,] }] }
];
SwalComponent.propDecorators = {
    title: [{ type: Input }],
    titleText: [{ type: Input }],
    text: [{ type: Input }],
    html: [{ type: Input }],
    footer: [{ type: Input }],
    type: [{ type: Input }],
    backdrop: [{ type: Input }],
    toast: [{ type: Input }],
    target: [{ type: Input }],
    input: [{ type: Input }],
    width: [{ type: Input }],
    padding: [{ type: Input }],
    background: [{ type: Input }],
    position: [{ type: Input }],
    grow: [{ type: Input }],
    customClass: [{ type: Input }],
    timer: [{ type: Input }],
    animation: [{ type: Input }],
    allowOutsideClick: [{ type: Input }],
    allowEscapeKey: [{ type: Input }],
    allowEnterKey: [{ type: Input }],
    showConfirmButton: [{ type: Input }],
    showCancelButton: [{ type: Input }],
    confirmButtonText: [{ type: Input }],
    cancelButtonText: [{ type: Input }],
    confirmButtonColor: [{ type: Input }],
    cancelButtonColor: [{ type: Input }],
    confirmButtonClass: [{ type: Input }],
    cancelButtonClass: [{ type: Input }],
    confirmButtonAriaLabel: [{ type: Input }],
    cancelButtonAriaLabel: [{ type: Input }],
    buttonsStyling: [{ type: Input }],
    reverseButtons: [{ type: Input }],
    focusConfirm: [{ type: Input }],
    focusCancel: [{ type: Input }],
    showCloseButton: [{ type: Input }],
    closeButtonAriaLabel: [{ type: Input }],
    showLoaderOnConfirm: [{ type: Input }],
    preConfirm: [{ type: Input }],
    imageUrl: [{ type: Input }],
    imageWidth: [{ type: Input }],
    imageHeight: [{ type: Input }],
    imageAlt: [{ type: Input }],
    imageClass: [{ type: Input }],
    inputPlaceholder: [{ type: Input }],
    inputValue: [{ type: Input }],
    inputOptions: [{ type: Input }],
    inputAutoTrim: [{ type: Input }],
    inputAttributes: [{ type: Input }],
    inputValidator: [{ type: Input }],
    inputClass: [{ type: Input }],
    progressSteps: [{ type: Input }],
    currentProgressStep: [{ type: Input }],
    progressStepsDistance: [{ type: Input }],
    beforeOpen: [{ type: Output }],
    open: [{ type: Output }],
    close: [{ type: Output }],
    confirm: [{ type: Output }],
    cancel: [{ type: Output }],
    options: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * [swal] directive. It takes a value that defines the Sweet Alert and can be of three types:
 *
 * 1) A simple array of two or three strings defining [title, text, type] - the type being optional, ex:
 *
 *    <button [swal]="['Title', 'Text']">Click me</button>
 *
 * 2) A native SweetAlert2 options object, ex:
 *
 *    <button [swal]="{ title: 'Title', text: 'Text' }">Click me</button>
 *
 * 3) A reference to an existing SwalComponent instance for more advanced uses, ex:
 *
 *    <button [swal]="mySwal">Click me</button>
 *    <swal #mySwal title="Title" text="Text"></swal>
 */
class SwalDirective {
    /**
     * @param {?} viewContainerRef
     * @param {?} resolver
     */
    constructor(viewContainerRef, resolver) {
        this.viewContainerRef = viewContainerRef;
        this.resolver = resolver;
        /**
         * Emits when the user clicks "Confirm".
         * Bears a value when using "input", resolved "preConfirm", etc.
         *
         * Example:
         *     public handleConfirm(email: string): void {
         *         // ... save user email
         *     }
         */
        this.confirm = new EventEmitter();
        /**
         * Emits when the user clicks "Cancel" (or dismisses the modal by any other way).
         * By default, it will emit a string representing the reason for which the SweetAlert has been closed, or the
         * value of a rejected "preConfirm".
         *
         * Example:
         *     public handleCancel(reason: string): void {
         *         // reason can be 'cancel', 'overlay', 'close', and 'timer'
         *         // ... do something
         *     }
         */
        this.cancel = new EventEmitter();
    }
    /**
     * SweetAlert2 options or a SwalComponent instance.
     * See the class doc block for more informations.
     * @param {?} options
     * @return {?}
     */
    set swal(options) {
        if (options instanceof SwalComponent) {
            this.swalInstance = options;
        }
        else if (Array.isArray(options)) {
            this.swalOptions = Swal.argsToParams(options);
        }
        else {
            this.swalOptions = options;
        }
    }
    /**
     * OnInit lifecycle handler.
     * Creates a SwalComponent instance if the user didn't provided one and binds on that component (confirm) and
     * (cancel) outputs to reemit on the directive.
     * @return {?}
     */
    ngOnInit() {
        if (!this.swalInstance) {
            /** @type {?} */
            const factory = this.resolver.resolveComponentFactory(SwalComponent);
            this.swalRef = this.viewContainerRef.createComponent(factory);
            this.swalInstance = this.swalRef.instance;
        }
    }
    /**
     * OnDestroy lifecycle handler.
     * Destroys the dynamically-created SwalComponent and unsubscribes from that component's (confirm) and (cancel).
     * @return {?}
     */
    ngOnDestroy() {
        if (this.swalRef) {
            this.swalRef.destroy();
        }
    }
    /**
     * Click handler.
     * The directive listens for onclick events on its host element.
     * When this happens, it shows the <swal> attached to this directive.
     * @param {?} event
     * @return {?}
     */
    onHostClicked(event) {
        event.preventDefault();
        event.stopImmediatePropagation();
        event.stopPropagation();
        if (this.swalOptions) {
            this.swalInstance.options = this.swalOptions;
        }
        /** @type {?} */
        const confirmSub = this.swalInstance.confirm.asObservable().subscribe(v => this.confirm.emit(v));
        /** @type {?} */
        const cancelSub = this.swalInstance.cancel.asObservable().subscribe(v => this.cancel.emit(v));
        this.swalInstance.show().then(unsubscribe);
        /**
         * @return {?}
         */
        function unsubscribe() {
            confirmSub.unsubscribe();
            cancelSub.unsubscribe();
        }
    }
}
SwalDirective.decorators = [
    { type: Directive, args: [{
                selector: '[swal]'
            },] }
];
/** @nocollapse */
SwalDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: ComponentFactoryResolver }
];
SwalDirective.propDecorators = {
    swal: [{ type: Input }],
    confirm: [{ type: Output }],
    cancel: [{ type: Output }],
    onHostClicked: [{ type: HostListener, args: ['click', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * \@internal
 * Holds a consumer's Angular template and displays it on a Sweet Alert.
 * See SwalPartialDirective for info about the covered feature.
 */
class SwalPartialComponent {
}
SwalPartialComponent.decorators = [
    { type: Component, args: [{
                template: '<ng-container *ngTemplateOutlet="template"></ng-container>',
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
SwalPartialComponent.propDecorators = {
    template: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * A structural directive that lets you use Angular templates inside of Sweet Alerts.
 * There are different targetable zones in a Sweet Alert: title, content, confirmButton, cancelButton, buttonsWrapper.
 * The default target is the content zone.
 *
 * Usage in your component's TypeScript code-behind (if you use another target than "content"):
 *
 * \@Component({ ... })
 *     export class MyComponent {
 *         public constructor(public readonly swalTargets: SwalPartialTargets) {
 *         }
 *     }
 *
 * Usage in the template:
 *
 *     <swal title="Fill the form" (confirm)="confirmHandler()">
 *         <!-- This form will be displayed as the alert main content
 *              Targets the alert's main content zone by default -->
 *         <form *swalPartial [formControl]="myForm">
 *             ...
 *         </form>
 *
 *         <!-- This targets the confirm button's inner content
 *              Notice the usage of ng-container to avoid creating an useless DOM element inside the button -->
 *         <ng-container *swalPartial="swalTargets.confirmButton">
 *              Send ({{ secondsLeft }} seconds left)
 *         </ng-container>
 *     <swal>
 */
class SwalPartialDirective {
    /**
     * @param {?} resolver
     * @param {?} injector
     * @param {?} app
     * @param {?} templateRef
     * @param {?} swalTargets
     * @param {?} swalComponent
     */
    constructor(resolver, injector, app, templateRef, swalTargets, swalComponent) {
        this.resolver = resolver;
        this.injector = injector;
        this.app = app;
        this.templateRef = templateRef;
        this.swalTargets = swalTargets;
        this.swalComponent = swalComponent;
    }
    /**
     * Subscribes to the the Sweet Alert appearance/disappearance to create/destroy the SwalPartialComponent that will
     * receive the consumer's template.
     * @return {?}
     */
    ngOnInit() {
        this.beforeOpenSubscription = this.swalComponent.beforeOpen.asObservable().subscribe(() => {
            //=> Create the SwalPartialComponent on the target DOM node in the Sweet Alert
            /** @type {?} */
            const targetEl = this.swalPartial ? this.swalPartial() : this.swalTargets.content();
            /** @type {?} */
            const factory = this.resolver.resolveComponentFactory(SwalPartialComponent);
            this.partialRef = factory.create(this.injector, [], targetEl);
            //=> Apply the consumer's template on the component
            this.partialRef.instance.template = this.templateRef;
            //=> Make the Angular app aware of that detached view so change detection works
            this.app.attachView(this.partialRef.hostView);
        });
        this.closeSubscription = this.swalComponent.close.asObservable().subscribe(() => {
            //=> Detach the partial component from the app and destroy it
            this.app.detachView(this.partialRef.hostView);
            this.partialRef.destroy();
        });
    }
    /**
     * Unsubscribes from the Sweet Alert appearance/disappearance.
     * @return {?}
     */
    ngOnDestroy() {
        this.beforeOpenSubscription.unsubscribe();
        this.closeSubscription.unsubscribe();
    }
}
SwalPartialDirective.decorators = [
    { type: Directive, args: [{
                selector: '[swalPartial]'
            },] }
];
/** @nocollapse */
SwalPartialDirective.ctorParameters = () => [
    { type: ComponentFactoryResolver },
    { type: Injector },
    { type: ApplicationRef },
    { type: TemplateRef },
    { type: SwalPartialTargets },
    { type: SwalComponent, decorators: [{ type: Host }] }
];
SwalPartialDirective.propDecorators = {
    swalPartial: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class SweetAlert2Module {
    /**
     * @param {?=} defaultSwalOptions
     * @return {?}
     */
    static forRoot(defaultSwalOptions) {
        return {
            ngModule: SweetAlert2Module,
            providers: [swalDefaultsProvider(defaultSwalOptions)]
        };
    }
}
SweetAlert2Module.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    SwalComponent, SwalPartialDirective, SwalPartialComponent,
                    SwalDirective
                ],
                providers: [
                    SwalPartialTargets
                ],
                imports: [
                    CommonModule
                ],
                exports: [
                    SwalComponent, SwalPartialDirective,
                    SwalDirective
                ],
                entryComponents: [
                    SwalComponent, SwalPartialComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

export { SwalPartialTargets, SwalComponent, SwalDirective, SwalPartialDirective, SweetAlert2Module, SwalDefaults as ɵa, swalDefaultsProvider as ɵb, SwalPartialComponent as ɵc };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3dlZXRhbGVydDItbmd4LXN3ZWV0YWxlcnQyLmpzLm1hcCIsInNvdXJjZXMiOlsibmc6Ly9Ac3dlZXRhbGVydDIvbmd4LXN3ZWV0YWxlcnQyL3N3YWwtcGFydGlhbC10YXJnZXRzLnRzIiwibmc6Ly9Ac3dlZXRhbGVydDIvbmd4LXN3ZWV0YWxlcnQyL2RpLnRzIiwibmc6Ly9Ac3dlZXRhbGVydDIvbmd4LXN3ZWV0YWxlcnQyL3N3YWwuY29tcG9uZW50LnRzIiwibmc6Ly9Ac3dlZXRhbGVydDIvbmd4LXN3ZWV0YWxlcnQyL3N3YWwuZGlyZWN0aXZlLnRzIiwibmc6Ly9Ac3dlZXRhbGVydDIvbmd4LXN3ZWV0YWxlcnQyL3N3YWwtcGFydGlhbC5jb21wb25lbnQudHMiLCJuZzovL0Bzd2VldGFsZXJ0Mi9uZ3gtc3dlZXRhbGVydDIvc3dhbC1wYXJ0aWFsLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHN3ZWV0YWxlcnQyL25neC1zd2VldGFsZXJ0Mi9zd2VldGFsZXJ0Mi5tb2R1bGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFN3YWwgZnJvbSAnc3dlZXRhbGVydDInO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gb2JqZWN0IG9mIHRhcmdldHMgZm9yIDxzd2FsPiBwYXJ0aWFscyAodXNlIHdpdGggKnN3YWxQYXJ0aWFsIGRpcmVjdGl2ZSkuXG4gKiBXZSBtdXN0IHVzZSB0aHVua3MgdG8gYWNjZXNzIHRoZSBTd2FsLiogZnVuY3Rpb25zIGxpc3RlZCBiZWxvdywgYmVjYXVzZSB0aGV5IGdldCBjcmVhdGVkIGFmdGVyIHRoZSBmaXJzdCBtb2RhbCBpc1xuICogc2hvd24sIHNvIHRoaXMgb2JqZWN0IGxldHMgdXMgcmVmZXJlbmNlIHRob3NlIGZ1bmN0aW9ucyBzYWZlbHkgYW5kIGluIGEgc3RhdGljYWxseS10eXBlZCBtYW5uZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBTd2FsUGFydGlhbFRhcmdldHMge1xuICAgIHB1YmxpYyByZWFkb25seSB0aXRsZSA9ICgpID0+IFN3YWwuZ2V0VGl0bGUoKTtcblxuICAgIHB1YmxpYyByZWFkb25seSBjb250ZW50ID0gKCkgPT4gU3dhbC5nZXRDb250ZW50KCk7XG5cbiAgICBwdWJsaWMgcmVhZG9ubHkgYWN0aW9ucyA9ICgpID0+IFN3YWwuZ2V0QWN0aW9ucygpO1xuXG4gICAgcHVibGljIHJlYWRvbmx5IGNvbmZpcm1CdXR0b24gPSAoKSA9PiBTd2FsLmdldENvbmZpcm1CdXR0b24oKTtcblxuICAgIHB1YmxpYyByZWFkb25seSBjYW5jZWxCdXR0b24gPSAoKSA9PiBTd2FsLmdldENhbmNlbEJ1dHRvbigpO1xuXG4gICAgcHVibGljIHJlYWRvbmx5IGZvb3RlciA9ICgpID0+IFN3YWwuZ2V0Rm9vdGVyKCk7XG59XG4iLCJpbXBvcnQgeyBJbmplY3Rpb25Ub2tlbiwgUHJvdmlkZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN3ZWV0QWxlcnRPcHRpb25zIH0gZnJvbSAnc3dlZXRhbGVydDInO1xuXG5leHBvcnQgY29uc3QgU3dhbERlZmF1bHRzID0gbmV3IEluamVjdGlvblRva2VuPFN3ZWV0QWxlcnRPcHRpb25zPignU3dhbERlZmF1bHRzJyk7XG5cbmV4cG9ydCBmdW5jdGlvbiBzd2FsRGVmYXVsdHNQcm92aWRlcihvcHRpb25zOiBTd2VldEFsZXJ0T3B0aW9ucyA9IHt9KTogUHJvdmlkZXIge1xuICAgIHJldHVybiB7XG4gICAgICAgIHByb3ZpZGU6IFN3YWxEZWZhdWx0cyxcbiAgICAgICAgdXNlVmFsdWU6IG9wdGlvbnNcbiAgICB9O1xufVxuIiwiaW1wb3J0IHtcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIEluamVjdCwgSW5wdXQsIE9uQ2hhbmdlcywgT25EZXN0cm95LCBPdXRwdXQsIFNpbXBsZUNoYW5nZXNcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgU3dhbCwgeyBTd2VldEFsZXJ0T3B0aW9ucyB9IGZyb20gJ3N3ZWV0YWxlcnQyJztcbmltcG9ydCB7IFN3YWxEZWZhdWx0cyB9IGZyb20gJy4vZGknO1xuaW1wb3J0ICogYXMgZXZlbnRzIGZyb20gJy4vc3dhbC1ldmVudHMnO1xuXG4vKipcbiAqIDxzd2FsPiBjb21wb25lbnQuIFNlZSB0aGUgUkVBRE1FLm1kIGZvciB1c2FnZS5cbiAqXG4gKiBJdCBjb250YWlucyBhIGJ1bmNoIG9mIEBJbnB1dHMgdGhhdCBoYXZlIGEgcGVyZmVjdCAxOjEgbWFwcGluZyB3aXRoIFN3ZWV0QWxlcnQyIG9wdGlvbnMuXG4gKiBUaGVpciB0eXBlcyBhcmUgZGlyZWN0bHkgY29taW5nIGZyb20gU3dlZXRBbGVydDIgdHlwZXMgZGVmaW50aXRpb25zLCBtZWFuaW5nIHRoYXQgbmd4LXN3ZWV0YWxlcnQyIGlzIHRpZ2h0bHkgY291cGxlZFxuICogdG8gU3dlZXRBbGVydDIsIGJ1dCBhbHNvIGlzIHR5cGUtc2FmZS5cbiAqXG4gKiAvIVxcIFNvbWUgU3dlZXRBbGVydCBvcHRpb25zIGFyZW4ndCBASW5wdXRzIGJ1dCBAT3V0cHV0czogb25CZWZvcmVPcGVuLCBvbk9wZW4sIGFuZCBvbkNsb3NlICh3aXRob3V0IFwib24qXCIgcHJlZml4KS5cbiAqICAgICBIb3dldmVyLCBwcmVDb25maXJtIGFuZCBpbnB1dFZhbGlkdG9yIGFyZSBzdGlsbCBASW5wdXRzIGJlY2F1c2UgdGhlcmUgYXJlIG5vdCBldmVudCBoYW5kbGVycywgdGhlcmUgY2FuJ3QgYmVcbiAqICAgICBtdWx0aXBsZSBsaXN0ZW5lcnMgYW5kIHdlIG5lZWQgdGhlIFByb21pc2UgdGhleSBtdXN0IHJldHVybi5cbiAqXG4gKiAvIVxcIFlvdSBjYW4gbm90aWNlIHRoYXQgdGhlIFN3ZWV0QWxlcnQyIGB1c2VSZWplY3Rpb25zYCBhbmQgYGV4cGVjdFJlamVjdGlvbnNgIGFyZSB0aGUgb25seSBvbmUgdG8gbm90IGhhdmVcbiAqICAgICBhbiBASW5wdXQoKS4gVGhhdCdzIGJlY2F1c2UgdGhleSBhcmUgZGVwcmVjYXRlZCBhbmQgbm90IHVzaW5nIHRoZSBkZWZhdWx0IHZhbHVlIG9mIHRoZXNlIHBhcmFtZXRlcnMgbGVhZHMgdG9cbiAqICAgICBjbHVua3kgY29udHJvbCBmbG93LiBUaGV5IGFyZSBzdXBwb3J0ZWQgKHVzZSBbb3B0aW9uc109XCJ7fVwiKSwgYnV0IHBsZWFzZSBkb24ndCB1c2UgdGhlbS5cbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdzd2FsJyxcbiAgICB0ZW1wbGF0ZTogJycsXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgU3dhbENvbXBvbmVudCBpbXBsZW1lbnRzIE9uQ2hhbmdlcywgT25EZXN0cm95IHtcbiAgICAvLyBJZiBTd2FsIGdldHMgbW9yZSB0aGFuIGEgaHVuZHJlZCBwcm9wcywgSSdsbCB3cml0ZSBhIGNvZGUgZ2VuZXJhdG9yLCBJIHByb21pc2UuXG4gICAgLy8gQW5kIEkgYWx3YXlzIHJlc29sdmUoKSBteSBwcm9taXNlcy5cbiAgICBASW5wdXQoKSBwdWJsaWMgdGl0bGU6IFN3ZWV0QWxlcnRPcHRpb25zWyd0aXRsZSddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyB0aXRsZVRleHQ6IFN3ZWV0QWxlcnRPcHRpb25zWyd0aXRsZVRleHQnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgdGV4dDogU3dlZXRBbGVydE9wdGlvbnNbJ3RleHQnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaHRtbDogU3dlZXRBbGVydE9wdGlvbnNbJ2h0bWwnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgZm9vdGVyOiBTd2VldEFsZXJ0T3B0aW9uc1snZm9vdGVyJ107XG4gICAgQElucHV0KCkgcHVibGljIHR5cGU6IFN3ZWV0QWxlcnRPcHRpb25zWyd0eXBlJ107XG4gICAgQElucHV0KCkgcHVibGljIGJhY2tkcm9wOiBTd2VldEFsZXJ0T3B0aW9uc1snYmFja2Ryb3AnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgdG9hc3Q6IFN3ZWV0QWxlcnRPcHRpb25zWyd0b2FzdCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyB0YXJnZXQ6IFN3ZWV0QWxlcnRPcHRpb25zWyd0YXJnZXQnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW5wdXQ6IFN3ZWV0QWxlcnRPcHRpb25zWydpbnB1dCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyB3aWR0aDogU3dlZXRBbGVydE9wdGlvbnNbJ3dpZHRoJ107XG4gICAgQElucHV0KCkgcHVibGljIHBhZGRpbmc6IFN3ZWV0QWxlcnRPcHRpb25zWydwYWRkaW5nJ107XG4gICAgQElucHV0KCkgcHVibGljIGJhY2tncm91bmQ6IFN3ZWV0QWxlcnRPcHRpb25zWydiYWNrZ3JvdW5kJ107XG4gICAgQElucHV0KCkgcHVibGljIHBvc2l0aW9uOiBTd2VldEFsZXJ0T3B0aW9uc1sncG9zaXRpb24nXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgZ3JvdzogU3dlZXRBbGVydE9wdGlvbnNbJ2dyb3cnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgY3VzdG9tQ2xhc3M6IFN3ZWV0QWxlcnRPcHRpb25zWydjdXN0b21DbGFzcyddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyB0aW1lcjogU3dlZXRBbGVydE9wdGlvbnNbJ3RpbWVyJ107XG4gICAgQElucHV0KCkgcHVibGljIGFuaW1hdGlvbjogU3dlZXRBbGVydE9wdGlvbnNbJ2FuaW1hdGlvbiddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBhbGxvd091dHNpZGVDbGljazogU3dlZXRBbGVydE9wdGlvbnNbJ2FsbG93T3V0c2lkZUNsaWNrJ107XG4gICAgQElucHV0KCkgcHVibGljIGFsbG93RXNjYXBlS2V5OiBTd2VldEFsZXJ0T3B0aW9uc1snYWxsb3dFc2NhcGVLZXknXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgYWxsb3dFbnRlcktleTogU3dlZXRBbGVydE9wdGlvbnNbJ2FsbG93RW50ZXJLZXknXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgc2hvd0NvbmZpcm1CdXR0b246IFN3ZWV0QWxlcnRPcHRpb25zWydzaG93Q29uZmlybUJ1dHRvbiddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBzaG93Q2FuY2VsQnV0dG9uOiBTd2VldEFsZXJ0T3B0aW9uc1snc2hvd0NhbmNlbEJ1dHRvbiddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjb25maXJtQnV0dG9uVGV4dDogU3dlZXRBbGVydE9wdGlvbnNbJ2NvbmZpcm1CdXR0b25UZXh0J107XG4gICAgQElucHV0KCkgcHVibGljIGNhbmNlbEJ1dHRvblRleHQ6IFN3ZWV0QWxlcnRPcHRpb25zWydjYW5jZWxCdXR0b25UZXh0J107XG4gICAgQElucHV0KCkgcHVibGljIGNvbmZpcm1CdXR0b25Db2xvcjogU3dlZXRBbGVydE9wdGlvbnNbJ2NvbmZpcm1CdXR0b25Db2xvciddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjYW5jZWxCdXR0b25Db2xvcjogU3dlZXRBbGVydE9wdGlvbnNbJ2NhbmNlbEJ1dHRvbkNvbG9yJ107XG4gICAgQElucHV0KCkgcHVibGljIGNvbmZpcm1CdXR0b25DbGFzczogU3dlZXRBbGVydE9wdGlvbnNbJ2NvbmZpcm1CdXR0b25DbGFzcyddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjYW5jZWxCdXR0b25DbGFzczogU3dlZXRBbGVydE9wdGlvbnNbJ2NhbmNlbEJ1dHRvbkNsYXNzJ107XG4gICAgQElucHV0KCkgcHVibGljIGNvbmZpcm1CdXR0b25BcmlhTGFiZWw6IFN3ZWV0QWxlcnRPcHRpb25zWydjb25maXJtQnV0dG9uQXJpYUxhYmVsJ107XG4gICAgQElucHV0KCkgcHVibGljIGNhbmNlbEJ1dHRvbkFyaWFMYWJlbDogU3dlZXRBbGVydE9wdGlvbnNbJ2NhbmNlbEJ1dHRvbkFyaWFMYWJlbCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBidXR0b25zU3R5bGluZzogU3dlZXRBbGVydE9wdGlvbnNbJ2J1dHRvbnNTdHlsaW5nJ107XG4gICAgQElucHV0KCkgcHVibGljIHJldmVyc2VCdXR0b25zOiBTd2VldEFsZXJ0T3B0aW9uc1sncmV2ZXJzZUJ1dHRvbnMnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgZm9jdXNDb25maXJtOiBTd2VldEFsZXJ0T3B0aW9uc1snZm9jdXNDb25maXJtJ107XG4gICAgQElucHV0KCkgcHVibGljIGZvY3VzQ2FuY2VsOiBTd2VldEFsZXJ0T3B0aW9uc1snZm9jdXNDYW5jZWwnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgc2hvd0Nsb3NlQnV0dG9uOiBTd2VldEFsZXJ0T3B0aW9uc1snc2hvd0Nsb3NlQnV0dG9uJ107XG4gICAgQElucHV0KCkgcHVibGljIGNsb3NlQnV0dG9uQXJpYUxhYmVsOiBTd2VldEFsZXJ0T3B0aW9uc1snY2xvc2VCdXR0b25BcmlhTGFiZWwnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgc2hvd0xvYWRlck9uQ29uZmlybTogU3dlZXRBbGVydE9wdGlvbnNbJ3Nob3dMb2FkZXJPbkNvbmZpcm0nXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgcHJlQ29uZmlybTogU3dlZXRBbGVydE9wdGlvbnNbJ3ByZUNvbmZpcm0nXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW1hZ2VVcmw6IFN3ZWV0QWxlcnRPcHRpb25zWydpbWFnZVVybCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbWFnZVdpZHRoOiBTd2VldEFsZXJ0T3B0aW9uc1snaW1hZ2VXaWR0aCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbWFnZUhlaWdodDogU3dlZXRBbGVydE9wdGlvbnNbJ2ltYWdlSGVpZ2h0J107XG4gICAgQElucHV0KCkgcHVibGljIGltYWdlQWx0OiBTd2VldEFsZXJ0T3B0aW9uc1snaW1hZ2VBbHQnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW1hZ2VDbGFzczogU3dlZXRBbGVydE9wdGlvbnNbJ2ltYWdlQ2xhc3MnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW5wdXRQbGFjZWhvbGRlcjogU3dlZXRBbGVydE9wdGlvbnNbJ2lucHV0UGxhY2Vob2xkZXInXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW5wdXRWYWx1ZTogU3dlZXRBbGVydE9wdGlvbnNbJ2lucHV0VmFsdWUnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW5wdXRPcHRpb25zOiBTd2VldEFsZXJ0T3B0aW9uc1snaW5wdXRPcHRpb25zJ107XG4gICAgQElucHV0KCkgcHVibGljIGlucHV0QXV0b1RyaW06IFN3ZWV0QWxlcnRPcHRpb25zWydpbnB1dEF1dG9UcmltJ107XG4gICAgQElucHV0KCkgcHVibGljIGlucHV0QXR0cmlidXRlczogU3dlZXRBbGVydE9wdGlvbnNbJ2lucHV0QXR0cmlidXRlcyddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbnB1dFZhbGlkYXRvcjogU3dlZXRBbGVydE9wdGlvbnNbJ2lucHV0VmFsaWRhdG9yJ107XG4gICAgQElucHV0KCkgcHVibGljIGlucHV0Q2xhc3M6IFN3ZWV0QWxlcnRPcHRpb25zWydpbnB1dENsYXNzJ107XG4gICAgQElucHV0KCkgcHVibGljIHByb2dyZXNzU3RlcHM6IFN3ZWV0QWxlcnRPcHRpb25zWydwcm9ncmVzc1N0ZXBzJ107XG4gICAgQElucHV0KCkgcHVibGljIGN1cnJlbnRQcm9ncmVzc1N0ZXA6IFN3ZWV0QWxlcnRPcHRpb25zWydjdXJyZW50UHJvZ3Jlc3NTdGVwJ107XG4gICAgQElucHV0KCkgcHVibGljIHByb2dyZXNzU3RlcHNEaXN0YW5jZTogU3dlZXRBbGVydE9wdGlvbnNbJ3Byb2dyZXNzU3RlcHNEaXN0YW5jZSddO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHMgYSBCZWZvcmVPcGVuRXZlbnQgd2hlbiB0aGUgbW9kYWwgRE9NIGVsZW1lbnQgaGFzIGJlZW4gY3JlYXRlZC5cbiAgICAgKiBVc2VmdWwgdG8gcGVyZm9ybSBET00gbXV0YXRpb25zIGJlZm9yZSB0aGUgbW9kYWwgaXMgc2hvd24uXG4gICAgICovXG4gICAgQE91dHB1dCgpIHB1YmxpYyByZWFkb25seSBiZWZvcmVPcGVuID0gbmV3IEV2ZW50RW1pdHRlcjxldmVudHMuQmVmb3JlT3BlbkV2ZW50PigpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gT3BlbkV2ZW50IHdoZW4gdGhlIG1vZGFsIGlzIHNob3duLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKSBwdWJsaWMgcmVhZG9ubHkgb3BlbiA9IG5ldyBFdmVudEVtaXR0ZXI8ZXZlbnRzLk9wZW5FdmVudD4oKTtcblxuICAgIC8qKlxuICAgICAqIEVtaXRzIGEgQ2xvc2VFdmVudCB3aGVuIG1vZGFsIGdldCBjbG9zZWQuXG4gICAgICovXG4gICAgQE91dHB1dCgpIHB1YmxpYyByZWFkb25seSBjbG9zZSA9IG5ldyBFdmVudEVtaXR0ZXI8ZXZlbnRzLkNsb3NlRXZlbnQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyB3aGVuIHRoZSB1c2VyIGNsaWNrcyBcIkNvbmZpcm1cIi5cbiAgICAgKiBCZWFycyBhIHZhbHVlIHdoZW4gdXNpbmcgXCJpbnB1dFwiLCByZXNvbHZlZCBcInByZUNvbmZpcm1cIiwgZXRjLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKiAgICAgcHVibGljIGhhbmRsZUNvbmZpcm0oZW1haWw6IHN0cmluZyk6IHZvaWQge1xuICAgICAqICAgICAgICAgLy8gLi4uIHNhdmUgdXNlciBlbWFpbFxuICAgICAqICAgICB9XG4gICAgICovXG4gICAgQE91dHB1dCgpIHB1YmxpYyByZWFkb25seSBjb25maXJtID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyB3aGVuIHRoZSB1c2VyIGNsaWNrcyBcIkNhbmNlbFwiIChvciBkaXNtaXNzZXMgdGhlIG1vZGFsIGJ5IGFueSBvdGhlciB3YXkpLlxuICAgICAqIEJ5IGRlZmF1bHQsIGl0IHdpbGwgZW1pdCBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHJlYXNvbiBmb3Igd2hpY2ggdGhlIFN3ZWV0QWxlcnQgaGFzIGJlZW4gY2xvc2VkLCBvciB0aGVcbiAgICAgKiB2YWx1ZSBvZiBhIHJlamVjdGVkIFwicHJlQ29uZmlybVwiLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKiAgICAgcHVibGljIGhhbmRsZUNhbmNlbChyZWFzb246IHN0cmluZyk6IHZvaWQge1xuICAgICAqICAgICAgICAgLy8gcmVhc29uIGNhbiBiZSAnY2FuY2VsJywgJ292ZXJsYXknLCAnY2xvc2UnLCBhbmQgJ3RpbWVyJ1xuICAgICAqICAgICAgICAgLy8gLi4uIGRvIHNvbWV0aGluZ1xuICAgICAqICAgICB9XG4gICAgICovXG4gICAgQE91dHB1dCgpIHB1YmxpYyByZWFkb25seSBjYW5jZWwgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCBvZiBTd2VldEFsZXJ0MiBuYXRpdmUgb3B0aW9ucywgdXNlZnVsIGlmOlxuICAgICAqICAtIHlvdSBkb24ndCB3YW50IHRvIHVzZSB0aGUgQElucHV0cyBmb3IgcHJhY3RpY2FsL3BoaWxvc29waGljYWwgcmVhc29ucyA7XG4gICAgICogIC0gdGhlcmUgYXJlIG1pc3NpbmcgQElucHV0cyBiZWNhdXNlIG5neC1zd2VldGFsZXJ0MiBpc24ndCB1cC10by1kYXRlIHdpdGggU3dlZXRBbGVydDIncyBsYXRlc3QgY2hhbmdlcy5cbiAgICAgKlxuICAgICAqIC8hXFwgQmUgYXdhcmUgdGhhdCB0aGUgb3B0aW9ucyBkZWZpbmVkIGluIHRoaXMgb2JqZWN0IHdpbGwgb3ZlcnJpZGUgdGhlIEBJbnB1dHMgb2YgdGhlIHNhbWUgbmFtZS5cbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgc2V0IG9wdGlvbnMob3B0aW9uczogU3dlZXRBbGVydE9wdGlvbnMpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucykuZm9yRWFjaCh0aGlzLm1hcmtUb3VjaGVkKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IG9wdGlvbnMoKTogU3dlZXRBbGVydE9wdGlvbnMge1xuICAgICAgICBjb25zdCBvcHRpb25zOiBTd2VldEFsZXJ0T3B0aW9ucyA9IHt9O1xuXG4gICAgICAgIC8vPT4gV2Ugd2lsbCBjb21wdXRlIHRoZSBvcHRpb25zIG9iamVjdCBiYXNlZCBvbiB0aGUgb3B0aW9uIGtleXMgdGhhdCBhcmUga25vd24gdG8gaGF2ZSBjaGFuZ2VkLlxuICAgICAgICAvLyBUaGF0IGF2b2lkcyBwYXNzaW5nIGEgZ2lnYW50aWMgb2JqZWN0IHRvIFN3ZWV0QWxlcnQyLCBtYWtpbmcgZGVidWdnaW5nIGVhc2llciBhbmQgcG90ZW50aWFsbHkgYXZvaWRpbmdcbiAgICAgICAgLy8gc2lkZSBlZmZlY3RzLlxuICAgICAgICB0aGlzLnRvdWNoZWRQcm9wcy5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgICAgICAgb3B0aW9uc1twcm9wXSA9ICh0aGlzIGFzIHsgW3Byb3A6IHN0cmluZ106IGFueSB9KVtwcm9wXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuXG4gICAgcHVibGljIG5hdGl2ZVN3YWwgPSBTd2FsO1xuXG4gICAgcHJpdmF0ZSBpc0N1cnJlbnRseVNob3duID0gZmFsc2U7XG5cbiAgICBwcml2YXRlIHJlYWRvbmx5IHRvdWNoZWRQcm9wcyA9IG5ldyBTZXQ8a2V5b2YgU3dlZXRBbGVydE9wdGlvbnM+KCk7XG5cbiAgICBwcml2YXRlIHJlYWRvbmx5IG1hcmtUb3VjaGVkID0gdGhpcy50b3VjaGVkUHJvcHMuYWRkLmJpbmQodGhpcy50b3VjaGVkUHJvcHMpO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKEBJbmplY3QoU3dhbERlZmF1bHRzKSBwcml2YXRlIHJlYWRvbmx5IGRlZmF1bHRTd2FsT3B0aW9uczogU3dlZXRBbGVydE9wdGlvbnMpIHtcbiAgICAgICAgLy89PiBGb3JjZSBgdGhpc2Agc2NvcGUgb2Ygc2hvdygpIG9uIHRoaXMgY29tcG9uZW50XG4gICAgICAgIC8vICAgVXNlZnVsIGZvciBkb2luZyB0aGluZ3MgbGlrZSAoY2xpY2spPVwibXlTd2FsLnNob3coKVwiLlxuICAgICAgICB0aGlzLnNob3cgPSB0aGlzLnNob3cuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICAgICAgICBPYmplY3Qua2V5cyhjaGFuZ2VzKVxuICAgICAgICAgICAgLmZpbHRlcihwcm9wID0+IHByb3AgIT09ICdvcHRpb25zJylcbiAgICAgICAgICAgIC5mb3JFYWNoKHRoaXMubWFya1RvdWNoZWQpO1xuICAgIH1cblxuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDdXJyZW50bHlTaG93bikge1xuICAgICAgICAgICAgU3dhbC5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2hvd3MgdGhlIFN3ZWV0QWxlcnQuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIHRoZSBTd2VldEFsZXJ0MiBwcm9taXNlIGZvciBjb252ZW5pZW5jZSBhbmQgdXNlIGluIGNvZGUgYmVoaW5kIHRlbXBsYXRlcy5cbiAgICAgKiBPdGhlcndpc2UsIChjb25maXJtKT1cIm15SGFuZGxlcigkZXZlbnQpXCIgYW5kIChjYW5jZWwpPVwibXlIYW5kbGVyKCRldmVudClcIiBjYW4gYmUgdXNlZCBpbiB0ZW1wbGF0ZXMuXG4gICAgICovXG4gICAgcHVibGljIHNob3coKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgICAgLy89PiBCdWlsZCB0aGUgU3dlZXRBbGVydDIgb3B0aW9uc1xuICAgICAgICBjb25zdCBvcHRpb25zOiBTd2VldEFsZXJ0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIC8vPT4gTWVyZ2Ugd2l0aCB0aGUgZGVmYXVsdCBtb2R1bGUtbGV2ZWwgb3B0aW9uc1xuICAgICAgICAgICAgLi4udGhpcy5kZWZhdWx0U3dhbE9wdGlvbnMsXG5cbiAgICAgICAgICAgIC8vPT4gTWVyZ2Ugd2l0aCBjYWxjdWxhdGVkIG9wdGlvbnMgc2V0IGZvciB0aGF0IHNwZWNpZmljIHN3YWxcbiAgICAgICAgICAgIC4uLnRoaXMub3B0aW9ucyxcblxuICAgICAgICAgICAgLy89PiBIYW5kbGUgbW9kYWwgbGlmZWN5Y2xlIGV2ZW50c1xuICAgICAgICAgICAgb25CZWZvcmVPcGVuOiAobW9kYWxFbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5iZWZvcmVPcGVuLmVtaXQoeyBtb2RhbEVsZW1lbnQgfSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBvbk9wZW46IChtb2RhbEVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzQ3VycmVudGx5U2hvd24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMub3Blbi5lbWl0KHsgbW9kYWxFbGVtZW50IH0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgb25DbG9zZTogKG1vZGFsRWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNDdXJyZW50bHlTaG93biA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UuZW1pdCh7IG1vZGFsRWxlbWVudCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLz0+IFNob3cgdGhlIFN3YWwhXG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBTd2FsLmZpcmUob3B0aW9ucyk7XG5cbiAgICAgICAgLy89PiBIYW5kbGUgKGNvbmZpcm0pIGFuZCAoY2FuY2VsKSBAT3V0cHV0c1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tc3RyaW5nLWxpdGVyYWxcbiAgICAgICAgY29uc3QgdXNlUmVqZWN0aW9ucyA9IChvcHRpb25zIGFzIHsgdXNlUmVqZWN0aW9ucz86IGJvb2xlYW4gfSkudXNlUmVqZWN0aW9ucztcblxuICAgICAgICBwcm9taXNlLnRoZW4oXG4gICAgICAgICAgICByZXN1bHQgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh1c2VSZWplY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlybS5lbWl0KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgndmFsdWUnIGluIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpcm0uZW1pdChyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsLmVtaXQocmVzdWx0LmRpc21pc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnIgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh1c2VSZWplY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsLmVtaXQoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgLy89PiBSZXR1cm4gdGhlIHVuYWx0ZXJlZCBwcm9taXNlXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbn1cbiIsImltcG9ydCB7XG4gICAgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBDb21wb25lbnRSZWYsIERpcmVjdGl2ZSwgRXZlbnRFbWl0dGVyLCBIb3N0TGlzdGVuZXIsIElucHV0LCBPbkRlc3Ryb3ksIE9uSW5pdCwgT3V0cHV0LFxuICAgIFZpZXdDb250YWluZXJSZWZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgU3dhbCwgeyBTd2VldEFsZXJ0QXJyYXlPcHRpb25zLCBTd2VldEFsZXJ0T3B0aW9ucyB9IGZyb20gJ3N3ZWV0YWxlcnQyJztcbmltcG9ydCB7IFN3YWxDb21wb25lbnQgfSBmcm9tICcuL3N3YWwuY29tcG9uZW50JztcblxuLyoqXG4gKiBbc3dhbF0gZGlyZWN0aXZlLiBJdCB0YWtlcyBhIHZhbHVlIHRoYXQgZGVmaW5lcyB0aGUgU3dlZXQgQWxlcnQgYW5kIGNhbiBiZSBvZiB0aHJlZSB0eXBlczpcbiAqXG4gKiAxKSBBIHNpbXBsZSBhcnJheSBvZiB0d28gb3IgdGhyZWUgc3RyaW5ncyBkZWZpbmluZyBbdGl0bGUsIHRleHQsIHR5cGVdIC0gdGhlIHR5cGUgYmVpbmcgb3B0aW9uYWwsIGV4OlxuICpcbiAqICAgIDxidXR0b24gW3N3YWxdPVwiWydUaXRsZScsICdUZXh0J11cIj5DbGljayBtZTwvYnV0dG9uPlxuICpcbiAqIDIpIEEgbmF0aXZlIFN3ZWV0QWxlcnQyIG9wdGlvbnMgb2JqZWN0LCBleDpcbiAqXG4gKiAgICA8YnV0dG9uIFtzd2FsXT1cInsgdGl0bGU6ICdUaXRsZScsIHRleHQ6ICdUZXh0JyB9XCI+Q2xpY2sgbWU8L2J1dHRvbj5cbiAqXG4gKiAzKSBBIHJlZmVyZW5jZSB0byBhbiBleGlzdGluZyBTd2FsQ29tcG9uZW50IGluc3RhbmNlIGZvciBtb3JlIGFkdmFuY2VkIHVzZXMsIGV4OlxuICpcbiAqICAgIDxidXR0b24gW3N3YWxdPVwibXlTd2FsXCI+Q2xpY2sgbWU8L2J1dHRvbj5cbiAqICAgIDxzd2FsICNteVN3YWwgdGl0bGU9XCJUaXRsZVwiIHRleHQ9XCJUZXh0XCI+PC9zd2FsPlxuICovXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1tzd2FsXSdcbn0pXG5leHBvcnQgY2xhc3MgU3dhbERpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcbiAgICAvKipcbiAgICAgKiBTd2VldEFsZXJ0MiBvcHRpb25zIG9yIGEgU3dhbENvbXBvbmVudCBpbnN0YW5jZS5cbiAgICAgKiBTZWUgdGhlIGNsYXNzIGRvYyBibG9jayBmb3IgbW9yZSBpbmZvcm1hdGlvbnMuXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIHNldCBzd2FsKG9wdGlvbnM6IFN3YWxDb21wb25lbnQgfCBTd2VldEFsZXJ0T3B0aW9ucyB8IFN3ZWV0QWxlcnRBcnJheU9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBTd2FsQ29tcG9uZW50KSB7XG4gICAgICAgICAgICB0aGlzLnN3YWxJbnN0YW5jZSA9IG9wdGlvbnM7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgICAgICAgdGhpcy5zd2FsT3B0aW9ucyA9IFN3YWwuYXJnc1RvUGFyYW1zKG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zd2FsT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyB3aGVuIHRoZSB1c2VyIGNsaWNrcyBcIkNvbmZpcm1cIi5cbiAgICAgKiBCZWFycyBhIHZhbHVlIHdoZW4gdXNpbmcgXCJpbnB1dFwiLCByZXNvbHZlZCBcInByZUNvbmZpcm1cIiwgZXRjLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKiAgICAgcHVibGljIGhhbmRsZUNvbmZpcm0oZW1haWw6IHN0cmluZyk6IHZvaWQge1xuICAgICAqICAgICAgICAgLy8gLi4uIHNhdmUgdXNlciBlbWFpbFxuICAgICAqICAgICB9XG4gICAgICovXG4gICAgQE91dHB1dCgpIHB1YmxpYyByZWFkb25seSBjb25maXJtID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyB3aGVuIHRoZSB1c2VyIGNsaWNrcyBcIkNhbmNlbFwiIChvciBkaXNtaXNzZXMgdGhlIG1vZGFsIGJ5IGFueSBvdGhlciB3YXkpLlxuICAgICAqIEJ5IGRlZmF1bHQsIGl0IHdpbGwgZW1pdCBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHJlYXNvbiBmb3Igd2hpY2ggdGhlIFN3ZWV0QWxlcnQgaGFzIGJlZW4gY2xvc2VkLCBvciB0aGVcbiAgICAgKiB2YWx1ZSBvZiBhIHJlamVjdGVkIFwicHJlQ29uZmlybVwiLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKiAgICAgcHVibGljIGhhbmRsZUNhbmNlbChyZWFzb246IHN0cmluZyk6IHZvaWQge1xuICAgICAqICAgICAgICAgLy8gcmVhc29uIGNhbiBiZSAnY2FuY2VsJywgJ292ZXJsYXknLCAnY2xvc2UnLCBhbmQgJ3RpbWVyJ1xuICAgICAqICAgICAgICAgLy8gLi4uIGRvIHNvbWV0aGluZ1xuICAgICAqICAgICB9XG4gICAgICovXG4gICAgQE91dHB1dCgpIHB1YmxpYyByZWFkb25seSBjYW5jZWwgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlIHVzZXIgZG9lcyBub3QgcHJvdmlkZXMgYSBTd2FsQ29tcG9uZW50IGluc3RhbmNlLCB3ZSBjcmVhdGUgaXQgb24tdGhlLWZseSBhbmQgYXNzaWduIHRoZSBwbGFpbi1vYmplY3RcbiAgICAgKiBvcHRpb25zIHRvIGl0LlxuICAgICAqIFRoaXMgZmllbGRzIGtlZXBzIGEgcmVmZXJlbmNlIHRvIHRoZSBkeW5hbWljYWxseS1jcmVhdGVkIDxzd2FsPiwgdG8gZGVzdHJveSBpdCBhbG9uZyB0aGlzIGRpcmVjdGl2ZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBwcml2YXRlIHN3YWxSZWY6IENvbXBvbmVudFJlZjxTd2FsQ29tcG9uZW50PjtcblxuICAgIC8qKlxuICAgICAqIEFuIGluc3RhbmNlIG9mIHRoZSA8c3dhbD4gY29tcG9uZW50IHRoYXQgdGhpcyBkaXJlY3RpdmUgY29udHJvbHMuXG4gICAgICogQ291bGQgYmUgYW4gaW5zdGFuY2UgcGFzc2VkIGJ5IHRoZSB1c2VyLCBvdGhlcndpc2UgaXQncyB0aGUgaW5zdGFuY2Ugd2UndmUgZHluYW1pY2FsbHkgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBwcml2YXRlIHN3YWxJbnN0YW5jZTogU3dhbENvbXBvbmVudDtcblxuICAgIC8qKlxuICAgICAqIEhvbGRzIHRoZSBuYXRpdmUgU3dlZXRBbGVydDIgb3B0aW9ucy5cbiAgICAgKiBFbXB0eSB3aGVuIHRoZSB1c2VyIHBhc3NlZCBhbiBleGlzdGluZyBTd2FsQ29tcG9uZW50IGluc3RhbmNlLlxuICAgICAqL1xuICAgIHByaXZhdGUgc3dhbE9wdGlvbnM6IFN3ZWV0QWxlcnRPcHRpb25zO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IHZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYsXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgcmVzb2x2ZXI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcikge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9uSW5pdCBsaWZlY3ljbGUgaGFuZGxlci5cbiAgICAgKiBDcmVhdGVzIGEgU3dhbENvbXBvbmVudCBpbnN0YW5jZSBpZiB0aGUgdXNlciBkaWRuJ3QgcHJvdmlkZWQgb25lIGFuZCBiaW5kcyBvbiB0aGF0IGNvbXBvbmVudCAoY29uZmlybSkgYW5kXG4gICAgICogKGNhbmNlbCkgb3V0cHV0cyB0byByZWVtaXQgb24gdGhlIGRpcmVjdGl2ZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5zd2FsSW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGZhY3RvcnkgPSB0aGlzLnJlc29sdmVyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KFN3YWxDb21wb25lbnQpO1xuXG4gICAgICAgICAgICB0aGlzLnN3YWxSZWYgPSB0aGlzLnZpZXdDb250YWluZXJSZWYuY3JlYXRlQ29tcG9uZW50KGZhY3RvcnkpO1xuICAgICAgICAgICAgdGhpcy5zd2FsSW5zdGFuY2UgPSB0aGlzLnN3YWxSZWYuaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPbkRlc3Ryb3kgbGlmZWN5Y2xlIGhhbmRsZXIuXG4gICAgICogRGVzdHJveXMgdGhlIGR5bmFtaWNhbGx5LWNyZWF0ZWQgU3dhbENvbXBvbmVudCBhbmQgdW5zdWJzY3JpYmVzIGZyb20gdGhhdCBjb21wb25lbnQncyAoY29uZmlybSkgYW5kIChjYW5jZWwpLlxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuc3dhbFJlZikge1xuICAgICAgICAgICAgdGhpcy5zd2FsUmVmLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsaWNrIGhhbmRsZXIuXG4gICAgICogVGhlIGRpcmVjdGl2ZSBsaXN0ZW5zIGZvciBvbmNsaWNrIGV2ZW50cyBvbiBpdHMgaG9zdCBlbGVtZW50LlxuICAgICAqIFdoZW4gdGhpcyBoYXBwZW5zLCBpdCBzaG93cyB0aGUgPHN3YWw+IGF0dGFjaGVkIHRvIHRoaXMgZGlyZWN0aXZlLlxuICAgICAqL1xuICAgIEBIb3N0TGlzdGVuZXIoJ2NsaWNrJywgWyckZXZlbnQnXSlcbiAgICBwdWJsaWMgb25Ib3N0Q2xpY2tlZChldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuc3dhbE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc3dhbEluc3RhbmNlLm9wdGlvbnMgPSB0aGlzLnN3YWxPcHRpb25zO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29uZmlybVN1YiA9IHRoaXMuc3dhbEluc3RhbmNlLmNvbmZpcm0uYXNPYnNlcnZhYmxlKCkuc3Vic2NyaWJlKHYgPT4gdGhpcy5jb25maXJtLmVtaXQodikpO1xuICAgICAgICBjb25zdCBjYW5jZWxTdWIgPSB0aGlzLnN3YWxJbnN0YW5jZS5jYW5jZWwuYXNPYnNlcnZhYmxlKCkuc3Vic2NyaWJlKHYgPT4gdGhpcy5jYW5jZWwuZW1pdCh2KSk7XG5cbiAgICAgICAgdGhpcy5zd2FsSW5zdGFuY2Uuc2hvdygpLnRoZW4odW5zdWJzY3JpYmUpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICAgICAgY29uZmlybVN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgY2FuY2VsU3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tcG9uZW50LCBJbnB1dCwgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEhvbGRzIGEgY29uc3VtZXIncyBBbmd1bGFyIHRlbXBsYXRlIGFuZCBkaXNwbGF5cyBpdCBvbiBhIFN3ZWV0IEFsZXJ0LlxuICogU2VlIFN3YWxQYXJ0aWFsRGlyZWN0aXZlIGZvciBpbmZvIGFib3V0IHRoZSBjb3ZlcmVkIGZlYXR1cmUuXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cInRlbXBsYXRlXCI+PC9uZy1jb250YWluZXI+JyxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBTd2FsUGFydGlhbENvbXBvbmVudCB7XG4gICAgQElucHV0KCkgcHVibGljIHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xufVxuIiwiaW1wb3J0IHtcbiAgICBBcHBsaWNhdGlvblJlZiwgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBDb21wb25lbnRSZWYsIERpcmVjdGl2ZSwgSG9zdCwgSW5qZWN0b3IsIElucHV0LCBPbkRlc3Ryb3ksIE9uSW5pdCxcbiAgICBUZW1wbGF0ZVJlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgU3dhbFBhcnRpYWxUYXJnZXRzIH0gZnJvbSAnLi9zd2FsLXBhcnRpYWwtdGFyZ2V0cyc7XG5pbXBvcnQgeyBTd2FsUGFydGlhbENvbXBvbmVudCB9IGZyb20gJy4vc3dhbC1wYXJ0aWFsLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBTd2FsQ29tcG9uZW50IH0gZnJvbSAnLi9zd2FsLmNvbXBvbmVudCc7XG5cbi8qKlxuICogQSBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZSB0aGF0IGxldHMgeW91IHVzZSBBbmd1bGFyIHRlbXBsYXRlcyBpbnNpZGUgb2YgU3dlZXQgQWxlcnRzLlxuICogVGhlcmUgYXJlIGRpZmZlcmVudCB0YXJnZXRhYmxlIHpvbmVzIGluIGEgU3dlZXQgQWxlcnQ6IHRpdGxlLCBjb250ZW50LCBjb25maXJtQnV0dG9uLCBjYW5jZWxCdXR0b24sIGJ1dHRvbnNXcmFwcGVyLlxuICogVGhlIGRlZmF1bHQgdGFyZ2V0IGlzIHRoZSBjb250ZW50IHpvbmUuXG4gKlxuICogVXNhZ2UgaW4geW91ciBjb21wb25lbnQncyBUeXBlU2NyaXB0IGNvZGUtYmVoaW5kIChpZiB5b3UgdXNlIGFub3RoZXIgdGFyZ2V0IHRoYW4gXCJjb250ZW50XCIpOlxuICpcbiAqICAgICBAQ29tcG9uZW50KHsgLi4uIH0pXG4gKiAgICAgZXhwb3J0IGNsYXNzIE15Q29tcG9uZW50IHtcbiAqICAgICAgICAgcHVibGljIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSBzd2FsVGFyZ2V0czogU3dhbFBhcnRpYWxUYXJnZXRzKSB7XG4gKiAgICAgICAgIH1cbiAqICAgICB9XG4gKlxuICogVXNhZ2UgaW4gdGhlIHRlbXBsYXRlOlxuICpcbiAqICAgICA8c3dhbCB0aXRsZT1cIkZpbGwgdGhlIGZvcm1cIiAoY29uZmlybSk9XCJjb25maXJtSGFuZGxlcigpXCI+XG4gKiAgICAgICAgIDwhLS0gVGhpcyBmb3JtIHdpbGwgYmUgZGlzcGxheWVkIGFzIHRoZSBhbGVydCBtYWluIGNvbnRlbnRcbiAqICAgICAgICAgICAgICBUYXJnZXRzIHRoZSBhbGVydCdzIG1haW4gY29udGVudCB6b25lIGJ5IGRlZmF1bHQgLS0+XG4gKiAgICAgICAgIDxmb3JtICpzd2FsUGFydGlhbCBbZm9ybUNvbnRyb2xdPVwibXlGb3JtXCI+XG4gKiAgICAgICAgICAgICAuLi5cbiAqICAgICAgICAgPC9mb3JtPlxuICpcbiAqICAgICAgICAgPCEtLSBUaGlzIHRhcmdldHMgdGhlIGNvbmZpcm0gYnV0dG9uJ3MgaW5uZXIgY29udGVudFxuICogICAgICAgICAgICAgIE5vdGljZSB0aGUgdXNhZ2Ugb2YgbmctY29udGFpbmVyIHRvIGF2b2lkIGNyZWF0aW5nIGFuIHVzZWxlc3MgRE9NIGVsZW1lbnQgaW5zaWRlIHRoZSBidXR0b24gLS0+XG4gKiAgICAgICAgIDxuZy1jb250YWluZXIgKnN3YWxQYXJ0aWFsPVwic3dhbFRhcmdldHMuY29uZmlybUJ1dHRvblwiPlxuICogICAgICAgICAgICAgIFNlbmQgKHt7IHNlY29uZHNMZWZ0IH19IHNlY29uZHMgbGVmdClcbiAqICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gKiAgICAgPHN3YWw+XG4gKi9cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3N3YWxQYXJ0aWFsXSdcbn0pXG5leHBvcnQgY2xhc3MgU3dhbFBhcnRpYWxEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG4gICAgLyoqXG4gICAgICogVGFrZXMgYSBcInBhcnRpYWwgdGFyZ2V0XCIgb3Igbm90aGluZyAod2lsbCB0YXJnZXQgbWFpbiBjb250ZW50IHpvbmUgYnkgZGVmYXVsdCkuXG4gICAgICpcbiAgICAgKiBTZWUgdGhlIHtAbGluayBTd2FsUGFydGlhbFRhcmdldHN9IHNlcnZpY2UgdG8gc2VlIHRoZSBhdmFpbGFibGUgdGFyZ2V0cy5cbiAgICAgKiBTZWUgdGhlIGNsYXNzIGRvYyBibG9jayBmb3IgbW9yZSBpbmZvcm1hdGlvbnMuXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIHN3YWxQYXJ0aWFsOiAoKSA9PiBIVE1MRWxlbWVudDtcblxuICAgIC8qKlxuICAgICAqIEhvbGRzIHRoZSBjb21wb25lbnQgcmVmZXJlbmNlIG9mIHRoZSBjb250cm9sbGVkIFN3YWxQYXJ0aWFsQ29tcG9uZW50IHRvIGRlc3Ryb3kgaXQgd2hlbiBubyBsb25nZXIgbmVlZGVkLlxuICAgICAqL1xuICAgIHByaXZhdGUgcGFydGlhbFJlZjogQ29tcG9uZW50UmVmPFN3YWxQYXJ0aWFsQ29tcG9uZW50PjtcblxuICAgIHByaXZhdGUgYmVmb3JlT3BlblN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuICAgIHByaXZhdGUgY2xvc2VTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IHJlc29sdmVyOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgaW5qZWN0b3I6IEluamVjdG9yLFxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IGFwcDogQXBwbGljYXRpb25SZWYsXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgdGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT4sXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgc3dhbFRhcmdldHM6IFN3YWxQYXJ0aWFsVGFyZ2V0cyxcbiAgICAgICAgQEhvc3QoKSBwcml2YXRlIHJlYWRvbmx5IHN3YWxDb21wb25lbnQ6IFN3YWxDb21wb25lbnQpIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVzIHRvIHRoZSB0aGUgU3dlZXQgQWxlcnQgYXBwZWFyYW5jZS9kaXNhcHBlYXJhbmNlIHRvIGNyZWF0ZS9kZXN0cm95IHRoZSBTd2FsUGFydGlhbENvbXBvbmVudCB0aGF0IHdpbGxcbiAgICAgKiByZWNlaXZlIHRoZSBjb25zdW1lcidzIHRlbXBsYXRlLlxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5iZWZvcmVPcGVuU3Vic2NyaXB0aW9uID0gdGhpcy5zd2FsQ29tcG9uZW50LmJlZm9yZU9wZW4uYXNPYnNlcnZhYmxlKCkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIC8vPT4gQ3JlYXRlIHRoZSBTd2FsUGFydGlhbENvbXBvbmVudCBvbiB0aGUgdGFyZ2V0IERPTSBub2RlIGluIHRoZSBTd2VldCBBbGVydFxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0RWwgPSB0aGlzLnN3YWxQYXJ0aWFsID8gdGhpcy5zd2FsUGFydGlhbCgpIDogdGhpcy5zd2FsVGFyZ2V0cy5jb250ZW50KCk7XG4gICAgICAgICAgICBjb25zdCBmYWN0b3J5ID0gdGhpcy5yZXNvbHZlci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShTd2FsUGFydGlhbENvbXBvbmVudCk7XG5cbiAgICAgICAgICAgIHRoaXMucGFydGlhbFJlZiA9IGZhY3RvcnkuY3JlYXRlKHRoaXMuaW5qZWN0b3IsIFtdLCB0YXJnZXRFbCk7XG5cbiAgICAgICAgICAgIC8vPT4gQXBwbHkgdGhlIGNvbnN1bWVyJ3MgdGVtcGxhdGUgb24gdGhlIGNvbXBvbmVudFxuICAgICAgICAgICAgdGhpcy5wYXJ0aWFsUmVmLmluc3RhbmNlLnRlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZVJlZjtcblxuICAgICAgICAgICAgLy89PiBNYWtlIHRoZSBBbmd1bGFyIGFwcCBhd2FyZSBvZiB0aGF0IGRldGFjaGVkIHZpZXcgc28gY2hhbmdlIGRldGVjdGlvbiB3b3Jrc1xuICAgICAgICAgICAgdGhpcy5hcHAuYXR0YWNoVmlldyh0aGlzLnBhcnRpYWxSZWYuaG9zdFZpZXcpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmNsb3NlU3Vic2NyaXB0aW9uID0gdGhpcy5zd2FsQ29tcG9uZW50LmNsb3NlLmFzT2JzZXJ2YWJsZSgpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAvLz0+IERldGFjaCB0aGUgcGFydGlhbCBjb21wb25lbnQgZnJvbSB0aGUgYXBwIGFuZCBkZXN0cm95IGl0XG4gICAgICAgICAgICB0aGlzLmFwcC5kZXRhY2hWaWV3KHRoaXMucGFydGlhbFJlZi5ob3N0Vmlldyk7XG4gICAgICAgICAgICB0aGlzLnBhcnRpYWxSZWYuZGVzdHJveSgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVbnN1YnNjcmliZXMgZnJvbSB0aGUgU3dlZXQgQWxlcnQgYXBwZWFyYW5jZS9kaXNhcHBlYXJhbmNlLlxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5iZWZvcmVPcGVuU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuY2xvc2VTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTW9kdWxlV2l0aFByb3ZpZGVycywgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN3ZWV0QWxlcnRPcHRpb25zIH0gZnJvbSAnc3dlZXRhbGVydDInO1xuaW1wb3J0IHsgc3dhbERlZmF1bHRzUHJvdmlkZXIgfSBmcm9tICcuL2RpJztcbmltcG9ydCB7IFN3YWxQYXJ0aWFsVGFyZ2V0cyB9IGZyb20gJy4vc3dhbC1wYXJ0aWFsLXRhcmdldHMnO1xuaW1wb3J0IHsgU3dhbFBhcnRpYWxDb21wb25lbnQgfSBmcm9tICcuL3N3YWwtcGFydGlhbC5jb21wb25lbnQnO1xuaW1wb3J0IHsgU3dhbFBhcnRpYWxEaXJlY3RpdmUgfSBmcm9tICcuL3N3YWwtcGFydGlhbC5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgU3dhbENvbXBvbmVudCB9IGZyb20gJy4vc3dhbC5jb21wb25lbnQnO1xuaW1wb3J0IHsgU3dhbERpcmVjdGl2ZSB9IGZyb20gJy4vc3dhbC5kaXJlY3RpdmUnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBTd2FsQ29tcG9uZW50LCBTd2FsUGFydGlhbERpcmVjdGl2ZSwgU3dhbFBhcnRpYWxDb21wb25lbnQsXG4gICAgICAgIFN3YWxEaXJlY3RpdmVcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICBTd2FsUGFydGlhbFRhcmdldHNcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIFN3YWxDb21wb25lbnQsIFN3YWxQYXJ0aWFsRGlyZWN0aXZlLFxuICAgICAgICBTd2FsRGlyZWN0aXZlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgU3dhbENvbXBvbmVudCwgU3dhbFBhcnRpYWxDb21wb25lbnRcbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIFN3ZWV0QWxlcnQyTW9kdWxlIHtcbiAgICBwdWJsaWMgc3RhdGljIGZvclJvb3QoZGVmYXVsdFN3YWxPcHRpb25zPzogU3dlZXRBbGVydE9wdGlvbnMpOiBNb2R1bGVXaXRoUHJvdmlkZXJzIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBTd2VldEFsZXJ0Mk1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW3N3YWxEZWZhdWx0c1Byb3ZpZGVyKGRlZmF1bHRTd2FsT3B0aW9ucyldXG4gICAgICAgIH07XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7O0FBT0EsTUFBYSxrQkFBa0I7SUFBL0I7UUFDb0IsVUFBSyxHQUFHLE1BQU0sSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBRTlCLFlBQU8sR0FBRyxNQUFNLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUVsQyxZQUFPLEdBQUcsTUFBTSxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7UUFFbEMsa0JBQWEsR0FBRyxNQUFNLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1FBRTlDLGlCQUFZLEdBQUcsTUFBTSxJQUFJ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