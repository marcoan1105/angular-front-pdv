(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('sweetalert2'), require('@angular/core'), require('@angular/common')) :
    typeof define === 'function' && define.amd ? define('@sweetalert2/ngx-sweetalert2', ['exports', 'sweetalert2', '@angular/core', '@angular/common'], factory) :
    (factory((global.swal = global.swal || {}, global.swal['ngx-sweetalert2'] = {}),global.swal,global.ng.core,global.ng.common));
}(this, (function (exports,Swal,core,common) { 'use strict';

    Swal = Swal && Swal.hasOwnProperty('default') ? Swal['default'] : Swal;

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Represents an object of targets for <swal> partials (use with *swalPartial directive).
     * We must use thunks to access the Swal.* functions listed below, because they get created after the first modal is
     * shown, so this object lets us reference those functions safely and in a statically-typed manner.
     */
    var /**
     * Represents an object of targets for <swal> partials (use with *swalPartial directive).
     * We must use thunks to access the Swal.* functions listed below, because they get created after the first modal is
     * shown, so this object lets us reference those functions safely and in a statically-typed manner.
     */ SwalPartialTargets = /** @class */ (function () {
        function SwalPartialTargets() {
            this.title = function () { return Swal.getTitle(); };
            this.content = function () { return Swal.getContent(); };
            this.actions = function () { return Swal.getActions(); };
            this.confirmButton = function () { return Swal.getConfirmButton(); };
            this.cancelButton = function () { return Swal.getCancelButton(); };
            this.footer = function () { return Swal.getFooter(); };
        }
        return SwalPartialTargets;
    }());

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var SwalDefaults = new core.InjectionToken('SwalDefaults');
    /**
     * @param {?=} options
     * @return {?}
     */
    function swalDefaultsProvider(options) {
        if (options === void 0) {
            options = {};
        }
        return {
            provide: SwalDefaults,
            useValue: options
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * <swal> component. See the README.md for usage.
     *
     * It contains a bunch of \@Inputs that have a perfect 1:1 mapping with SweetAlert2 options.
     * Their types are directly coming from SweetAlert2 types defintitions, meaning that ngx-sweetalert2 is tightly coupled
     * to SweetAlert2, but also is type-safe.
     *
     * /!\ Some SweetAlert options aren't \@Inputs but \@Outputs: onBeforeOpen, onOpen, and onClose (without "on*" prefix).
     *     However, preConfirm and inputValidtor are still \@Inputs because there are not event handlers, there can't be
     *     multiple listeners and we need the Promise they must return.
     *
     * /!\ You can notice that the SweetAlert2 `useRejections` and `expectRejections` are the only one to not have
     *     an \@Input(). That's because they are deprecated and not using the default value of these parameters leads to
     *     clunky control flow. They are supported (use [options]="{}"), but please don't use them.
     */
    var SwalComponent = /** @class */ (function () {
        function SwalComponent(defaultSwalOptions) {
            this.defaultSwalOptions = defaultSwalOptions;
            /**
             * Emits a BeforeOpenEvent when the modal DOM element has been created.
             * Useful to perform DOM mutations before the modal is shown.
             */
            this.beforeOpen = new core.EventEmitter();
            /**
             * Emits an OpenEvent when the modal is shown.
             */
            this.open = new core.EventEmitter();
            /**
             * Emits a CloseEvent when modal get closed.
             */
            this.close = new core.EventEmitter();
            /**
             * Emits when the user clicks "Confirm".
             * Bears a value when using "input", resolved "preConfirm", etc.
             *
             * Example:
             *     public handleConfirm(email: string): void {
             *         // ... save user email
             *     }
             */
            this.confirm = new core.EventEmitter();
            /**
             * Emits when the user clicks "Cancel" (or dismisses the modal by any other way).
             * By default, it will emit a string representing the reason for which the SweetAlert has been closed, or the
             * value of a rejected "preConfirm".
             *
             * Example:
             *     public handleCancel(reason: string): void {
             *         // reason can be 'cancel', 'overlay', 'close', and 'timer'
             *         // ... do something
             *     }
             */
            this.cancel = new core.EventEmitter();
            this.nativeSwal = Swal;
            this.isCurrentlyShown = false;
            this.touchedProps = new Set();
            this.markTouched = this.touchedProps.add.bind(this.touchedProps);
            //=> Force `this` scope of show() on this component
            //   Useful for doing things like (click)="mySwal.show()".
            this.show = this.show.bind(this);
        }
        Object.defineProperty(SwalComponent.prototype, "options", {
            get: /**
             * @return {?}
             */ function () {
                var _this = this;
                /** @type {?} */
                var options = {};
                //=> We will compute the options object based on the option keys that are known to have changed.
                // That avoids passing a gigantic object to SweetAlert2, making debugging easier and potentially avoiding
                // side effects.
                this.touchedProps.forEach(function (prop) {
                    options[prop] = (( /** @type {?} */(_this)))[prop];
                });
                return options;
            },
            /**
             * An object of SweetAlert2 native options, useful if:
             *  - you don't want to use the @Inputs for practical/philosophical reasons ;
             *  - there are missing @Inputs because ngx-sweetalert2 isn't up-to-date with SweetAlert2's latest changes.
             *
             * /!\ Be aware that the options defined in this object will override the @Inputs of the same name.
             */
            set: /**
             * An object of SweetAlert2 native options, useful if:
             *  - you don't want to use the \@Inputs for practical/philosophical reasons ;
             *  - there are missing \@Inputs because ngx-sweetalert2 isn't up-to-date with SweetAlert2's latest changes.
             *
             * /!\ Be aware that the options defined in this object will override the \@Inputs of the same name.
             * @param {?} options
             * @return {?}
             */ function (options) {
                Object.assign(this, options);
                Object.keys(options).forEach(this.markTouched);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} changes
         * @return {?}
         */
        SwalComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                Object.keys(changes)
                    .filter(function (prop) { return prop !== 'options'; })
                    .forEach(this.markTouched);
            };
        /**
         * @return {?}
         */
        SwalComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                if (this.isCurrentlyShown) {
                    Swal.close();
                }
            };
        /**
         * Shows the SweetAlert.
         *
         * Returns the SweetAlert2 promise for convenience and use in code behind templates.
         * Otherwise, (confirm)="myHandler($event)" and (cancel)="myHandler($event)" can be used in templates.
         */
        /**
         * Shows the SweetAlert.
         *
         * Returns the SweetAlert2 promise for convenience and use in code behind templates.
         * Otherwise, (confirm)="myHandler($event)" and (cancel)="myHandler($event)" can be used in templates.
         * @return {?}
         */
        SwalComponent.prototype.show = /**
         * Shows the SweetAlert.
         *
         * Returns the SweetAlert2 promise for convenience and use in code behind templates.
         * Otherwise, (confirm)="myHandler($event)" and (cancel)="myHandler($event)" can be used in templates.
         * @return {?}
         */
            function () {
                var _this = this;
                //=> Build the SweetAlert2 options
                /** @type {?} */
                var options = __assign({}, this.defaultSwalOptions, this.options, { onBeforeOpen: function (modalElement) {
                        _this.beforeOpen.emit({ modalElement: modalElement });
                    }, onOpen: function (modalElement) {
                        _this.isCurrentlyShown = true;
                        _this.open.emit({ modalElement: modalElement });
                    }, onClose: function (modalElement) {
                        _this.isCurrentlyShown = false;
                        _this.close.emit({ modalElement: modalElement });
                    } });
                //=> Show the Swal!
                /** @type {?} */
                var promise = Swal.fire(options);
                //=> Handle (confirm) and (cancel) @Outputs
                // tslint:disable-next-line:no-string-literal
                /** @type {?} */
                var useRejections = (( /** @type {?} */(options))).useRejections;
                promise.then(function (result) {
                    if (useRejections) {
                        _this.confirm.emit(result);
                    }
                    else if ('value' in result) {
                        _this.confirm.emit(result.value);
                    }
                    else {
                        _this.cancel.emit(result.dismiss);
                    }
                }, function (err) {
                    if (useRejections) {
                        _this.cancel.emit(err);
                    }
                });
                //=> Return the unaltered promise
                return promise;
            };
        SwalComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'swal',
                        template: '',
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        SwalComponent.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: core.Inject, args: [SwalDefaults,] }] }
            ];
        };
        SwalComponent.propDecorators = {
            title: [{ type: core.Input }],
            titleText: [{ type: core.Input }],
            text: [{ type: core.Input }],
            html: [{ type: core.Input }],
            footer: [{ type: core.Input }],
            type: [{ type: core.Input }],
            backdrop: [{ type: core.Input }],
            toast: [{ type: core.Input }],
            target: [{ type: core.Input }],
            input: [{ type: core.Input }],
            width: [{ type: core.Input }],
            padding: [{ type: core.Input }],
            background: [{ type: core.Input }],
            position: [{ type: core.Input }],
            grow: [{ type: core.Input }],
            customClass: [{ type: core.Input }],
            timer: [{ type: core.Input }],
            animation: [{ type: core.Input }],
            allowOutsideClick: [{ type: core.Input }],
            allowEscapeKey: [{ type: core.Input }],
            allowEnterKey: [{ type: core.Input }],
            showConfirmButton: [{ type: core.Input }],
            showCancelButton: [{ type: core.Input }],
            confirmButtonText: [{ type: core.Input }],
            cancelButtonText: [{ type: core.Input }],
            confirmButtonColor: [{ type: core.Input }],
            cancelButtonColor: [{ type: core.Input }],
            confirmButtonClass: [{ type: core.Input }],
            cancelButtonClass: [{ type: core.Input }],
            confirmButtonAriaLabel: [{ type: core.Input }],
            cancelButtonAriaLabel: [{ type: core.Input }],
            buttonsStyling: [{ type: core.Input }],
            reverseButtons: [{ type: core.Input }],
            focusConfirm: [{ type: core.Input }],
            focusCancel: [{ type: core.Input }],
            showCloseButton: [{ type: core.Input }],
            closeButtonAriaLabel: [{ type: core.Input }],
            showLoaderOnConfirm: [{ type: core.Input }],
            preConfirm: [{ type: core.Input }],
            imageUrl: [{ type: core.Input }],
            imageWidth: [{ type: core.Input }],
            imageHeight: [{ type: core.Input }],
            imageAlt: [{ type: core.Input }],
            imageClass: [{ type: core.Input }],
            inputPlaceholder: [{ type: core.Input }],
            inputValue: [{ type: core.Input }],
            inputOptions: [{ type: core.Input }],
            inputAutoTrim: [{ type: core.Input }],
            inputAttributes: [{ type: core.Input }],
            inputValidator: [{ type: core.Input }],
            inputClass: [{ type: core.Input }],
            progressSteps: [{ type: core.Input }],
            currentProgressStep: [{ type: core.Input }],
            progressStepsDistance: [{ type: core.Input }],
            beforeOpen: [{ type: core.Output }],
            open: [{ type: core.Output }],
            close: [{ type: core.Output }],
            confirm: [{ type: core.Output }],
            cancel: [{ type: core.Output }],
            options: [{ type: core.Input }]
        };
        return SwalComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * [swal] directive. It takes a value that defines the Sweet Alert and can be of three types:
     *
     * 1) A simple array of two or three strings defining [title, text, type] - the type being optional, ex:
     *
     *    <button [swal]="['Title', 'Text']">Click me</button>
     *
     * 2) A native SweetAlert2 options object, ex:
     *
     *    <button [swal]="{ title: 'Title', text: 'Text' }">Click me</button>
     *
     * 3) A reference to an existing SwalComponent instance for more advanced uses, ex:
     *
     *    <button [swal]="mySwal">Click me</button>
     *    <swal #mySwal title="Title" text="Text"></swal>
     */
    var SwalDirective = /** @class */ (function () {
        function SwalDirective(viewContainerRef, resolver) {
            this.viewContainerRef = viewContainerRef;
            this.resolver = resolver;
            /**
             * Emits when the user clicks "Confirm".
             * Bears a value when using "input", resolved "preConfirm", etc.
             *
             * Example:
             *     public handleConfirm(email: string): void {
             *         // ... save user email
             *     }
             */
            this.confirm = new core.EventEmitter();
            /**
             * Emits when the user clicks "Cancel" (or dismisses the modal by any other way).
             * By default, it will emit a string representing the reason for which the SweetAlert has been closed, or the
             * value of a rejected "preConfirm".
             *
             * Example:
             *     public handleCancel(reason: string): void {
             *         // reason can be 'cancel', 'overlay', 'close', and 'timer'
             *         // ... do something
             *     }
             */
            this.cancel = new core.EventEmitter();
        }
        Object.defineProperty(SwalDirective.prototype, "swal", {
            /**
             * SweetAlert2 options or a SwalComponent instance.
             * See the class doc block for more informations.
             */
            set: /**
             * SweetAlert2 options or a SwalComponent instance.
             * See the class doc block for more informations.
             * @param {?} options
             * @return {?}
             */ function (options) {
                if (options instanceof SwalComponent) {
                    this.swalInstance = options;
                }
                else if (Array.isArray(options)) {
                    this.swalOptions = Swal.argsToParams(options);
                }
                else {
                    this.swalOptions = options;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * OnInit lifecycle handler.
         * Creates a SwalComponent instance if the user didn't provided one and binds on that component (confirm) and
         * (cancel) outputs to reemit on the directive.
         */
        /**
         * OnInit lifecycle handler.
         * Creates a SwalComponent instance if the user didn't provided one and binds on that component (confirm) and
         * (cancel) outputs to reemit on the directive.
         * @return {?}
         */
        SwalDirective.prototype.ngOnInit = /**
         * OnInit lifecycle handler.
         * Creates a SwalComponent instance if the user didn't provided one and binds on that component (confirm) and
         * (cancel) outputs to reemit on the directive.
         * @return {?}
         */
            function () {
                if (!this.swalInstance) {
                    /** @type {?} */
                    var factory = this.resolver.resolveComponentFactory(SwalComponent);
                    this.swalRef = this.viewContainerRef.createComponent(factory);
                    this.swalInstance = this.swalRef.instance;
                }
            };
        /**
         * OnDestroy lifecycle handler.
         * Destroys the dynamically-created SwalComponent and unsubscribes from that component's (confirm) and (cancel).
         */
        /**
         * OnDestroy lifecycle handler.
         * Destroys the dynamically-created SwalComponent and unsubscribes from that component's (confirm) and (cancel).
         * @return {?}
         */
        SwalDirective.prototype.ngOnDestroy = /**
         * OnDestroy lifecycle handler.
         * Destroys the dynamically-created SwalComponent and unsubscribes from that component's (confirm) and (cancel).
         * @return {?}
         */
            function () {
                if (this.swalRef) {
                    this.swalRef.destroy();
                }
            };
        /**
         * Click handler.
         * The directive listens for onclick events on its host element.
         * When this happens, it shows the <swal> attached to this directive.
         */
        /**
         * Click handler.
         * The directive listens for onclick events on its host element.
         * When this happens, it shows the <swal> attached to this directive.
         * @param {?} event
         * @return {?}
         */
        SwalDirective.prototype.onHostClicked = /**
         * Click handler.
         * The directive listens for onclick events on its host element.
         * When this happens, it shows the <swal> attached to this directive.
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var _this = this;
                event.preventDefault();
                event.stopImmediatePropagation();
                event.stopPropagation();
                if (this.swalOptions) {
                    this.swalInstance.options = this.swalOptions;
                }
                /** @type {?} */
                var confirmSub = this.swalInstance.confirm.asObservable().subscribe(function (v) { return _this.confirm.emit(v); });
                /** @type {?} */
                var cancelSub = this.swalInstance.cancel.asObservable().subscribe(function (v) { return _this.cancel.emit(v); });
                this.swalInstance.show().then(unsubscribe);
                /**
                 * @return {?}
                 */
                function unsubscribe() {
                    confirmSub.unsubscribe();
                    cancelSub.unsubscribe();
                }
            };
        SwalDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[swal]'
                    },] }
        ];
        /** @nocollapse */
        SwalDirective.ctorParameters = function () {
            return [
                { type: core.ViewContainerRef },
                { type: core.ComponentFactoryResolver }
            ];
        };
        SwalDirective.propDecorators = {
            swal: [{ type: core.Input }],
            confirm: [{ type: core.Output }],
            cancel: [{ type: core.Output }],
            onHostClicked: [{ type: core.HostListener, args: ['click', ['$event'],] }]
        };
        return SwalDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * \@internal
     * Holds a consumer's Angular template and displays it on a Sweet Alert.
     * See SwalPartialDirective for info about the covered feature.
     */
    var SwalPartialComponent = /** @class */ (function () {
        function SwalPartialComponent() {
        }
        SwalPartialComponent.decorators = [
            { type: core.Component, args: [{
                        template: '<ng-container *ngTemplateOutlet="template"></ng-container>',
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        SwalPartialComponent.propDecorators = {
            template: [{ type: core.Input }]
        };
        return SwalPartialComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * A structural directive that lets you use Angular templates inside of Sweet Alerts.
     * There are different targetable zones in a Sweet Alert: title, content, confirmButton, cancelButton, buttonsWrapper.
     * The default target is the content zone.
     *
     * Usage in your component's TypeScript code-behind (if you use another target than "content"):
     *
     * \@Component({ ... })
     *     export class MyComponent {
     *         public constructor(public readonly swalTargets: SwalPartialTargets) {
     *         }
     *     }
     *
     * Usage in the template:
     *
     *     <swal title="Fill the form" (confirm)="confirmHandler()">
     *         <!-- This form will be displayed as the alert main content
     *              Targets the alert's main content zone by default -->
     *         <form *swalPartial [formControl]="myForm">
     *             ...
     *         </form>
     *
     *         <!-- This targets the confirm button's inner content
     *              Notice the usage of ng-container to avoid creating an useless DOM element inside the button -->
     *         <ng-container *swalPartial="swalTargets.confirmButton">
     *              Send ({{ secondsLeft }} seconds left)
     *         </ng-container>
     *     <swal>
     */
    var SwalPartialDirective = /** @class */ (function () {
        function SwalPartialDirective(resolver, injector, app, templateRef, swalTargets, swalComponent) {
            this.resolver = resolver;
            this.injector = injector;
            this.app = app;
            this.templateRef = templateRef;
            this.swalTargets = swalTargets;
            this.swalComponent = swalComponent;
        }
        /**
         * Subscribes to the the Sweet Alert appearance/disappearance to create/destroy the SwalPartialComponent that will
         * receive the consumer's template.
         */
        /**
         * Subscribes to the the Sweet Alert appearance/disappearance to create/destroy the SwalPartialComponent that will
         * receive the consumer's template.
         * @return {?}
         */
        SwalPartialDirective.prototype.ngOnInit = /**
         * Subscribes to the the Sweet Alert appearance/disappearance to create/destroy the SwalPartialComponent that will
         * receive the consumer's template.
         * @return {?}
         */
            function () {
                var _this = this;
                this.beforeOpenSubscription = this.swalComponent.beforeOpen.asObservable().subscribe(function () {
                    //=> Create the SwalPartialComponent on the target DOM node in the Sweet Alert
                    /** @type {?} */
                    var targetEl = _this.swalPartial ? _this.swalPartial() : _this.swalTargets.content();
                    /** @type {?} */
                    var factory = _this.resolver.resolveComponentFactory(SwalPartialComponent);
                    _this.partialRef = factory.create(_this.injector, [], targetEl);
                    //=> Apply the consumer's template on the component
                    _this.partialRef.instance.template = _this.templateRef;
                    //=> Make the Angular app aware of that detached view so change detection works
                    _this.app.attachView(_this.partialRef.hostView);
                });
                this.closeSubscription = this.swalComponent.close.asObservable().subscribe(function () {
                    //=> Detach the partial component from the app and destroy it
                    _this.app.detachView(_this.partialRef.hostView);
                    _this.partialRef.destroy();
                });
            };
        /**
         * Unsubscribes from the Sweet Alert appearance/disappearance.
         */
        /**
         * Unsubscribes from the Sweet Alert appearance/disappearance.
         * @return {?}
         */
        SwalPartialDirective.prototype.ngOnDestroy = /**
         * Unsubscribes from the Sweet Alert appearance/disappearance.
         * @return {?}
         */
            function () {
                this.beforeOpenSubscription.unsubscribe();
                this.closeSubscription.unsubscribe();
            };
        SwalPartialDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[swalPartial]'
                    },] }
        ];
        /** @nocollapse */
        SwalPartialDirective.ctorParameters = function () {
            return [
                { type: core.ComponentFactoryResolver },
                { type: core.Injector },
                { type: core.ApplicationRef },
                { type: core.TemplateRef },
                { type: SwalPartialTargets },
                { type: SwalComponent, decorators: [{ type: core.Host }] }
            ];
        };
        SwalPartialDirective.propDecorators = {
            swalPartial: [{ type: core.Input }]
        };
        return SwalPartialDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var SweetAlert2Module = /** @class */ (function () {
        function SweetAlert2Module() {
        }
        /**
         * @param {?=} defaultSwalOptions
         * @return {?}
         */
        SweetAlert2Module.forRoot = /**
         * @param {?=} defaultSwalOptions
         * @return {?}
         */
            function (defaultSwalOptions) {
                return {
                    ngModule: SweetAlert2Module,
                    providers: [swalDefaultsProvider(defaultSwalOptions)]
                };
            };
        SweetAlert2Module.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            SwalComponent, SwalPartialDirective, SwalPartialComponent,
                            SwalDirective
                        ],
                        providers: [
                            SwalPartialTargets
                        ],
                        imports: [
                            common.CommonModule
                        ],
                        exports: [
                            SwalComponent, SwalPartialDirective,
                            SwalDirective
                        ],
                        entryComponents: [
                            SwalComponent, SwalPartialComponent
                        ]
                    },] }
        ];
        return SweetAlert2Module;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    exports.SwalPartialTargets = SwalPartialTargets;
    exports.SwalComponent = SwalComponent;
    exports.SwalDirective = SwalDirective;
    exports.SwalPartialDirective = SwalPartialDirective;
    exports.SweetAlert2Module = SweetAlert2Module;
    exports.ɵa = SwalDefaults;
    exports.ɵb = swalDefaultsProvider;
    exports.ɵc = SwalPartialComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3dlZXRhbGVydDItbmd4LXN3ZWV0YWxlcnQyLnVtZC5qcy5tYXAiLCJzb3VyY2VzIjpbIm5nOi8vQHN3ZWV0YWxlcnQyL25neC1zd2VldGFsZXJ0Mi9zd2FsLXBhcnRpYWwtdGFyZ2V0cy50cyIsIm5vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanMiLCJuZzovL0Bzd2VldGFsZXJ0Mi9uZ3gtc3dlZXRhbGVydDIvZGkudHMiLCJuZzovL0Bzd2VldGFsZXJ0Mi9uZ3gtc3dlZXRhbGVydDIvc3dhbC5jb21wb25lbnQudHMiLCJuZzovL0Bzd2VldGFsZXJ0Mi9uZ3gtc3dlZXRhbGVydDIvc3dhbC5kaXJlY3RpdmUudHMiLCJuZzovL0Bzd2VldGFsZXJ0Mi9uZ3gtc3dlZXRhbGVydDIvc3dhbC1wYXJ0aWFsLmNvbXBvbmVudC50cyIsIm5nOi8vQHN3ZWV0YWxlcnQyL25neC1zd2VldGFsZXJ0Mi9zd2FsLXBhcnRpYWwuZGlyZWN0aXZlLnRzIiwibmc6Ly9Ac3dlZXRhbGVydDIvbmd4LXN3ZWV0YWxlcnQyL3N3ZWV0YWxlcnQyLm1vZHVsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgU3dhbCBmcm9tICdzd2VldGFsZXJ0Mic7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBvYmplY3Qgb2YgdGFyZ2V0cyBmb3IgPHN3YWw+IHBhcnRpYWxzICh1c2Ugd2l0aCAqc3dhbFBhcnRpYWwgZGlyZWN0aXZlKS5cbiAqIFdlIG11c3QgdXNlIHRodW5rcyB0byBhY2Nlc3MgdGhlIFN3YWwuKiBmdW5jdGlvbnMgbGlzdGVkIGJlbG93LCBiZWNhdXNlIHRoZXkgZ2V0IGNyZWF0ZWQgYWZ0ZXIgdGhlIGZpcnN0IG1vZGFsIGlzXG4gKiBzaG93biwgc28gdGhpcyBvYmplY3QgbGV0cyB1cyByZWZlcmVuY2UgdGhvc2UgZnVuY3Rpb25zIHNhZmVseSBhbmQgaW4gYSBzdGF0aWNhbGx5LXR5cGVkIG1hbm5lci5cbiAqL1xuZXhwb3J0IGNsYXNzIFN3YWxQYXJ0aWFsVGFyZ2V0cyB7XG4gICAgcHVibGljIHJlYWRvbmx5IHRpdGxlID0gKCkgPT4gU3dhbC5nZXRUaXRsZSgpO1xuXG4gICAgcHVibGljIHJlYWRvbmx5IGNvbnRlbnQgPSAoKSA9PiBTd2FsLmdldENvbnRlbnQoKTtcblxuICAgIHB1YmxpYyByZWFkb25seSBhY3Rpb25zID0gKCkgPT4gU3dhbC5nZXRBY3Rpb25zKCk7XG5cbiAgICBwdWJsaWMgcmVhZG9ubHkgY29uZmlybUJ1dHRvbiA9ICgpID0+IFN3YWwuZ2V0Q29uZmlybUJ1dHRvbigpO1xuXG4gICAgcHVibGljIHJlYWRvbmx5IGNhbmNlbEJ1dHRvbiA9ICgpID0+IFN3YWwuZ2V0Q2FuY2VsQnV0dG9uKCk7XG5cbiAgICBwdWJsaWMgcmVhZG9ubHkgZm9vdGVyID0gKCkgPT4gU3dhbC5nZXRGb290ZXIoKTtcbn1cbiIsIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMClcclxuICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBleHBvcnRzKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xyXG4gICAgdmFyIGksIHA7XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcclxuICAgIHJlc3VsdC5kZWZhdWx0ID0gbW9kO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XHJcbn1cclxuIiwiaW1wb3J0IHsgSW5qZWN0aW9uVG9rZW4sIFByb3ZpZGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTd2VldEFsZXJ0T3B0aW9ucyB9IGZyb20gJ3N3ZWV0YWxlcnQyJztcblxuZXhwb3J0IGNvbnN0IFN3YWxEZWZhdWx0cyA9IG5ldyBJbmplY3Rpb25Ub2tlbjxTd2VldEFsZXJ0T3B0aW9ucz4oJ1N3YWxEZWZhdWx0cycpO1xuXG5leHBvcnQgZnVuY3Rpb24gc3dhbERlZmF1bHRzUHJvdmlkZXIob3B0aW9uczogU3dlZXRBbGVydE9wdGlvbnMgPSB7fSk6IFByb3ZpZGVyIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcm92aWRlOiBTd2FsRGVmYXVsdHMsXG4gICAgICAgIHVzZVZhbHVlOiBvcHRpb25zXG4gICAgfTtcbn1cbiIsImltcG9ydCB7XG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbmplY3QsIElucHV0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSwgT3V0cHV0LCBTaW1wbGVDaGFuZ2VzXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IFN3YWwsIHsgU3dlZXRBbGVydE9wdGlvbnMgfSBmcm9tICdzd2VldGFsZXJ0Mic7XG5pbXBvcnQgeyBTd2FsRGVmYXVsdHMgfSBmcm9tICcuL2RpJztcbmltcG9ydCAqIGFzIGV2ZW50cyBmcm9tICcuL3N3YWwtZXZlbnRzJztcblxuLyoqXG4gKiA8c3dhbD4gY29tcG9uZW50LiBTZWUgdGhlIFJFQURNRS5tZCBmb3IgdXNhZ2UuXG4gKlxuICogSXQgY29udGFpbnMgYSBidW5jaCBvZiBASW5wdXRzIHRoYXQgaGF2ZSBhIHBlcmZlY3QgMToxIG1hcHBpbmcgd2l0aCBTd2VldEFsZXJ0MiBvcHRpb25zLlxuICogVGhlaXIgdHlwZXMgYXJlIGRpcmVjdGx5IGNvbWluZyBmcm9tIFN3ZWV0QWxlcnQyIHR5cGVzIGRlZmludGl0aW9ucywgbWVhbmluZyB0aGF0IG5neC1zd2VldGFsZXJ0MiBpcyB0aWdodGx5IGNvdXBsZWRcbiAqIHRvIFN3ZWV0QWxlcnQyLCBidXQgYWxzbyBpcyB0eXBlLXNhZmUuXG4gKlxuICogLyFcXCBTb21lIFN3ZWV0QWxlcnQgb3B0aW9ucyBhcmVuJ3QgQElucHV0cyBidXQgQE91dHB1dHM6IG9uQmVmb3JlT3Blbiwgb25PcGVuLCBhbmQgb25DbG9zZSAod2l0aG91dCBcIm9uKlwiIHByZWZpeCkuXG4gKiAgICAgSG93ZXZlciwgcHJlQ29uZmlybSBhbmQgaW5wdXRWYWxpZHRvciBhcmUgc3RpbGwgQElucHV0cyBiZWNhdXNlIHRoZXJlIGFyZSBub3QgZXZlbnQgaGFuZGxlcnMsIHRoZXJlIGNhbid0IGJlXG4gKiAgICAgbXVsdGlwbGUgbGlzdGVuZXJzIGFuZCB3ZSBuZWVkIHRoZSBQcm9taXNlIHRoZXkgbXVzdCByZXR1cm4uXG4gKlxuICogLyFcXCBZb3UgY2FuIG5vdGljZSB0aGF0IHRoZSBTd2VldEFsZXJ0MiBgdXNlUmVqZWN0aW9uc2AgYW5kIGBleHBlY3RSZWplY3Rpb25zYCBhcmUgdGhlIG9ubHkgb25lIHRvIG5vdCBoYXZlXG4gKiAgICAgYW4gQElucHV0KCkuIFRoYXQncyBiZWNhdXNlIHRoZXkgYXJlIGRlcHJlY2F0ZWQgYW5kIG5vdCB1c2luZyB0aGUgZGVmYXVsdCB2YWx1ZSBvZiB0aGVzZSBwYXJhbWV0ZXJzIGxlYWRzIHRvXG4gKiAgICAgY2x1bmt5IGNvbnRyb2wgZmxvdy4gVGhleSBhcmUgc3VwcG9ydGVkICh1c2UgW29wdGlvbnNdPVwie31cIiksIGJ1dCBwbGVhc2UgZG9uJ3QgdXNlIHRoZW0uXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnc3dhbCcsXG4gICAgdGVtcGxhdGU6ICcnLFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuZXhwb3J0IGNsYXNzIFN3YWxDb21wb25lbnQgaW1wbGVtZW50cyBPbkNoYW5nZXMsIE9uRGVzdHJveSB7XG4gICAgLy8gSWYgU3dhbCBnZXRzIG1vcmUgdGhhbiBhIGh1bmRyZWQgcHJvcHMsIEknbGwgd3JpdGUgYSBjb2RlIGdlbmVyYXRvciwgSSBwcm9taXNlLlxuICAgIC8vIEFuZCBJIGFsd2F5cyByZXNvbHZlKCkgbXkgcHJvbWlzZXMuXG4gICAgQElucHV0KCkgcHVibGljIHRpdGxlOiBTd2VldEFsZXJ0T3B0aW9uc1sndGl0bGUnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgdGl0bGVUZXh0OiBTd2VldEFsZXJ0T3B0aW9uc1sndGl0bGVUZXh0J107XG4gICAgQElucHV0KCkgcHVibGljIHRleHQ6IFN3ZWV0QWxlcnRPcHRpb25zWyd0ZXh0J107XG4gICAgQElucHV0KCkgcHVibGljIGh0bWw6IFN3ZWV0QWxlcnRPcHRpb25zWydodG1sJ107XG4gICAgQElucHV0KCkgcHVibGljIGZvb3RlcjogU3dlZXRBbGVydE9wdGlvbnNbJ2Zvb3RlciddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyB0eXBlOiBTd2VldEFsZXJ0T3B0aW9uc1sndHlwZSddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBiYWNrZHJvcDogU3dlZXRBbGVydE9wdGlvbnNbJ2JhY2tkcm9wJ107XG4gICAgQElucHV0KCkgcHVibGljIHRvYXN0OiBTd2VldEFsZXJ0T3B0aW9uc1sndG9hc3QnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgdGFyZ2V0OiBTd2VldEFsZXJ0T3B0aW9uc1sndGFyZ2V0J107XG4gICAgQElucHV0KCkgcHVibGljIGlucHV0OiBTd2VldEFsZXJ0T3B0aW9uc1snaW5wdXQnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgd2lkdGg6IFN3ZWV0QWxlcnRPcHRpb25zWyd3aWR0aCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBwYWRkaW5nOiBTd2VldEFsZXJ0T3B0aW9uc1sncGFkZGluZyddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBiYWNrZ3JvdW5kOiBTd2VldEFsZXJ0T3B0aW9uc1snYmFja2dyb3VuZCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBwb3NpdGlvbjogU3dlZXRBbGVydE9wdGlvbnNbJ3Bvc2l0aW9uJ107XG4gICAgQElucHV0KCkgcHVibGljIGdyb3c6IFN3ZWV0QWxlcnRPcHRpb25zWydncm93J107XG4gICAgQElucHV0KCkgcHVibGljIGN1c3RvbUNsYXNzOiBTd2VldEFsZXJ0T3B0aW9uc1snY3VzdG9tQ2xhc3MnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgdGltZXI6IFN3ZWV0QWxlcnRPcHRpb25zWyd0aW1lciddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBhbmltYXRpb246IFN3ZWV0QWxlcnRPcHRpb25zWydhbmltYXRpb24nXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgYWxsb3dPdXRzaWRlQ2xpY2s6IFN3ZWV0QWxlcnRPcHRpb25zWydhbGxvd091dHNpZGVDbGljayddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBhbGxvd0VzY2FwZUtleTogU3dlZXRBbGVydE9wdGlvbnNbJ2FsbG93RXNjYXBlS2V5J107XG4gICAgQElucHV0KCkgcHVibGljIGFsbG93RW50ZXJLZXk6IFN3ZWV0QWxlcnRPcHRpb25zWydhbGxvd0VudGVyS2V5J107XG4gICAgQElucHV0KCkgcHVibGljIHNob3dDb25maXJtQnV0dG9uOiBTd2VldEFsZXJ0T3B0aW9uc1snc2hvd0NvbmZpcm1CdXR0b24nXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgc2hvd0NhbmNlbEJ1dHRvbjogU3dlZXRBbGVydE9wdGlvbnNbJ3Nob3dDYW5jZWxCdXR0b24nXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgY29uZmlybUJ1dHRvblRleHQ6IFN3ZWV0QWxlcnRPcHRpb25zWydjb25maXJtQnV0dG9uVGV4dCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjYW5jZWxCdXR0b25UZXh0OiBTd2VldEFsZXJ0T3B0aW9uc1snY2FuY2VsQnV0dG9uVGV4dCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjb25maXJtQnV0dG9uQ29sb3I6IFN3ZWV0QWxlcnRPcHRpb25zWydjb25maXJtQnV0dG9uQ29sb3InXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgY2FuY2VsQnV0dG9uQ29sb3I6IFN3ZWV0QWxlcnRPcHRpb25zWydjYW5jZWxCdXR0b25Db2xvciddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjb25maXJtQnV0dG9uQ2xhc3M6IFN3ZWV0QWxlcnRPcHRpb25zWydjb25maXJtQnV0dG9uQ2xhc3MnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgY2FuY2VsQnV0dG9uQ2xhc3M6IFN3ZWV0QWxlcnRPcHRpb25zWydjYW5jZWxCdXR0b25DbGFzcyddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjb25maXJtQnV0dG9uQXJpYUxhYmVsOiBTd2VldEFsZXJ0T3B0aW9uc1snY29uZmlybUJ1dHRvbkFyaWFMYWJlbCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjYW5jZWxCdXR0b25BcmlhTGFiZWw6IFN3ZWV0QWxlcnRPcHRpb25zWydjYW5jZWxCdXR0b25BcmlhTGFiZWwnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgYnV0dG9uc1N0eWxpbmc6IFN3ZWV0QWxlcnRPcHRpb25zWydidXR0b25zU3R5bGluZyddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyByZXZlcnNlQnV0dG9uczogU3dlZXRBbGVydE9wdGlvbnNbJ3JldmVyc2VCdXR0b25zJ107XG4gICAgQElucHV0KCkgcHVibGljIGZvY3VzQ29uZmlybTogU3dlZXRBbGVydE9wdGlvbnNbJ2ZvY3VzQ29uZmlybSddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBmb2N1c0NhbmNlbDogU3dlZXRBbGVydE9wdGlvbnNbJ2ZvY3VzQ2FuY2VsJ107XG4gICAgQElucHV0KCkgcHVibGljIHNob3dDbG9zZUJ1dHRvbjogU3dlZXRBbGVydE9wdGlvbnNbJ3Nob3dDbG9zZUJ1dHRvbiddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjbG9zZUJ1dHRvbkFyaWFMYWJlbDogU3dlZXRBbGVydE9wdGlvbnNbJ2Nsb3NlQnV0dG9uQXJpYUxhYmVsJ107XG4gICAgQElucHV0KCkgcHVibGljIHNob3dMb2FkZXJPbkNvbmZpcm06IFN3ZWV0QWxlcnRPcHRpb25zWydzaG93TG9hZGVyT25Db25maXJtJ107XG4gICAgQElucHV0KCkgcHVibGljIHByZUNvbmZpcm06IFN3ZWV0QWxlcnRPcHRpb25zWydwcmVDb25maXJtJ107XG4gICAgQElucHV0KCkgcHVibGljIGltYWdlVXJsOiBTd2VldEFsZXJ0T3B0aW9uc1snaW1hZ2VVcmwnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW1hZ2VXaWR0aDogU3dlZXRBbGVydE9wdGlvbnNbJ2ltYWdlV2lkdGgnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW1hZ2VIZWlnaHQ6IFN3ZWV0QWxlcnRPcHRpb25zWydpbWFnZUhlaWdodCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbWFnZUFsdDogU3dlZXRBbGVydE9wdGlvbnNbJ2ltYWdlQWx0J107XG4gICAgQElucHV0KCkgcHVibGljIGltYWdlQ2xhc3M6IFN3ZWV0QWxlcnRPcHRpb25zWydpbWFnZUNsYXNzJ107XG4gICAgQElucHV0KCkgcHVibGljIGlucHV0UGxhY2Vob2xkZXI6IFN3ZWV0QWxlcnRPcHRpb25zWydpbnB1dFBsYWNlaG9sZGVyJ107XG4gICAgQElucHV0KCkgcHVibGljIGlucHV0VmFsdWU6IFN3ZWV0QWxlcnRPcHRpb25zWydpbnB1dFZhbHVlJ107XG4gICAgQElucHV0KCkgcHVibGljIGlucHV0T3B0aW9uczogU3dlZXRBbGVydE9wdGlvbnNbJ2lucHV0T3B0aW9ucyddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbnB1dEF1dG9UcmltOiBTd2VldEFsZXJ0T3B0aW9uc1snaW5wdXRBdXRvVHJpbSddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbnB1dEF0dHJpYnV0ZXM6IFN3ZWV0QWxlcnRPcHRpb25zWydpbnB1dEF0dHJpYnV0ZXMnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW5wdXRWYWxpZGF0b3I6IFN3ZWV0QWxlcnRPcHRpb25zWydpbnB1dFZhbGlkYXRvciddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbnB1dENsYXNzOiBTd2VldEFsZXJ0T3B0aW9uc1snaW5wdXRDbGFzcyddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBwcm9ncmVzc1N0ZXBzOiBTd2VldEFsZXJ0T3B0aW9uc1sncHJvZ3Jlc3NTdGVwcyddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjdXJyZW50UHJvZ3Jlc3NTdGVwOiBTd2VldEFsZXJ0T3B0aW9uc1snY3VycmVudFByb2dyZXNzU3RlcCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBwcm9ncmVzc1N0ZXBzRGlzdGFuY2U6IFN3ZWV0QWxlcnRPcHRpb25zWydwcm9ncmVzc1N0ZXBzRGlzdGFuY2UnXTtcblxuICAgIC8qKlxuICAgICAqIEVtaXRzIGEgQmVmb3JlT3BlbkV2ZW50IHdoZW4gdGhlIG1vZGFsIERPTSBlbGVtZW50IGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICogVXNlZnVsIHRvIHBlcmZvcm0gRE9NIG11dGF0aW9ucyBiZWZvcmUgdGhlIG1vZGFsIGlzIHNob3duLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKSBwdWJsaWMgcmVhZG9ubHkgYmVmb3JlT3BlbiA9IG5ldyBFdmVudEVtaXR0ZXI8ZXZlbnRzLkJlZm9yZU9wZW5FdmVudD4oKTtcblxuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIE9wZW5FdmVudCB3aGVuIHRoZSBtb2RhbCBpcyBzaG93bi5cbiAgICAgKi9cbiAgICBAT3V0cHV0KCkgcHVibGljIHJlYWRvbmx5IG9wZW4gPSBuZXcgRXZlbnRFbWl0dGVyPGV2ZW50cy5PcGVuRXZlbnQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhIENsb3NlRXZlbnQgd2hlbiBtb2RhbCBnZXQgY2xvc2VkLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKSBwdWJsaWMgcmVhZG9ubHkgY2xvc2UgPSBuZXcgRXZlbnRFbWl0dGVyPGV2ZW50cy5DbG9zZUV2ZW50PigpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHMgd2hlbiB0aGUgdXNlciBjbGlja3MgXCJDb25maXJtXCIuXG4gICAgICogQmVhcnMgYSB2YWx1ZSB3aGVuIHVzaW5nIFwiaW5wdXRcIiwgcmVzb2x2ZWQgXCJwcmVDb25maXJtXCIsIGV0Yy5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICogICAgIHB1YmxpYyBoYW5kbGVDb25maXJtKGVtYWlsOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgKiAgICAgICAgIC8vIC4uLiBzYXZlIHVzZXIgZW1haWxcbiAgICAgKiAgICAgfVxuICAgICAqL1xuICAgIEBPdXRwdXQoKSBwdWJsaWMgcmVhZG9ubHkgY29uZmlybSA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHMgd2hlbiB0aGUgdXNlciBjbGlja3MgXCJDYW5jZWxcIiAob3IgZGlzbWlzc2VzIHRoZSBtb2RhbCBieSBhbnkgb3RoZXIgd2F5KS5cbiAgICAgKiBCeSBkZWZhdWx0LCBpdCB3aWxsIGVtaXQgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSByZWFzb24gZm9yIHdoaWNoIHRoZSBTd2VldEFsZXJ0IGhhcyBiZWVuIGNsb3NlZCwgb3IgdGhlXG4gICAgICogdmFsdWUgb2YgYSByZWplY3RlZCBcInByZUNvbmZpcm1cIi5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICogICAgIHB1YmxpYyBoYW5kbGVDYW5jZWwocmVhc29uOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgKiAgICAgICAgIC8vIHJlYXNvbiBjYW4gYmUgJ2NhbmNlbCcsICdvdmVybGF5JywgJ2Nsb3NlJywgYW5kICd0aW1lcidcbiAgICAgKiAgICAgICAgIC8vIC4uLiBkbyBzb21ldGhpbmdcbiAgICAgKiAgICAgfVxuICAgICAqL1xuICAgIEBPdXRwdXQoKSBwdWJsaWMgcmVhZG9ubHkgY2FuY2VsID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3Qgb2YgU3dlZXRBbGVydDIgbmF0aXZlIG9wdGlvbnMsIHVzZWZ1bCBpZjpcbiAgICAgKiAgLSB5b3UgZG9uJ3Qgd2FudCB0byB1c2UgdGhlIEBJbnB1dHMgZm9yIHByYWN0aWNhbC9waGlsb3NvcGhpY2FsIHJlYXNvbnMgO1xuICAgICAqICAtIHRoZXJlIGFyZSBtaXNzaW5nIEBJbnB1dHMgYmVjYXVzZSBuZ3gtc3dlZXRhbGVydDIgaXNuJ3QgdXAtdG8tZGF0ZSB3aXRoIFN3ZWV0QWxlcnQyJ3MgbGF0ZXN0IGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiAvIVxcIEJlIGF3YXJlIHRoYXQgdGhlIG9wdGlvbnMgZGVmaW5lZCBpbiB0aGlzIG9iamVjdCB3aWxsIG92ZXJyaWRlIHRoZSBASW5wdXRzIG9mIHRoZSBzYW1lIG5hbWUuXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIHNldCBvcHRpb25zKG9wdGlvbnM6IFN3ZWV0QWxlcnRPcHRpb25zKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgb3B0aW9ucyk7XG4gICAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMpLmZvckVhY2godGhpcy5tYXJrVG91Y2hlZCk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBvcHRpb25zKCk6IFN3ZWV0QWxlcnRPcHRpb25zIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uczogU3dlZXRBbGVydE9wdGlvbnMgPSB7fTtcblxuICAgICAgICAvLz0+IFdlIHdpbGwgY29tcHV0ZSB0aGUgb3B0aW9ucyBvYmplY3QgYmFzZWQgb24gdGhlIG9wdGlvbiBrZXlzIHRoYXQgYXJlIGtub3duIHRvIGhhdmUgY2hhbmdlZC5cbiAgICAgICAgLy8gVGhhdCBhdm9pZHMgcGFzc2luZyBhIGdpZ2FudGljIG9iamVjdCB0byBTd2VldEFsZXJ0MiwgbWFraW5nIGRlYnVnZ2luZyBlYXNpZXIgYW5kIHBvdGVudGlhbGx5IGF2b2lkaW5nXG4gICAgICAgIC8vIHNpZGUgZWZmZWN0cy5cbiAgICAgICAgdGhpcy50b3VjaGVkUHJvcHMuZm9yRWFjaChwcm9wID0+IHtcbiAgICAgICAgICAgIG9wdGlvbnNbcHJvcF0gPSAodGhpcyBhcyB7IFtwcm9wOiBzdHJpbmddOiBhbnkgfSlbcHJvcF07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cblxuICAgIHB1YmxpYyBuYXRpdmVTd2FsID0gU3dhbDtcblxuICAgIHByaXZhdGUgaXNDdXJyZW50bHlTaG93biA9IGZhbHNlO1xuXG4gICAgcHJpdmF0ZSByZWFkb25seSB0b3VjaGVkUHJvcHMgPSBuZXcgU2V0PGtleW9mIFN3ZWV0QWxlcnRPcHRpb25zPigpO1xuXG4gICAgcHJpdmF0ZSByZWFkb25seSBtYXJrVG91Y2hlZCA9IHRoaXMudG91Y2hlZFByb3BzLmFkZC5iaW5kKHRoaXMudG91Y2hlZFByb3BzKTtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihASW5qZWN0KFN3YWxEZWZhdWx0cykgcHJpdmF0ZSByZWFkb25seSBkZWZhdWx0U3dhbE9wdGlvbnM6IFN3ZWV0QWxlcnRPcHRpb25zKSB7XG4gICAgICAgIC8vPT4gRm9yY2UgYHRoaXNgIHNjb3BlIG9mIHNob3coKSBvbiB0aGlzIGNvbXBvbmVudFxuICAgICAgICAvLyAgIFVzZWZ1bCBmb3IgZG9pbmcgdGhpbmdzIGxpa2UgKGNsaWNrKT1cIm15U3dhbC5zaG93KClcIi5cbiAgICAgICAgdGhpcy5zaG93ID0gdGhpcy5zaG93LmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgcHVibGljIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICAgICAgT2JqZWN0LmtleXMoY2hhbmdlcylcbiAgICAgICAgICAgIC5maWx0ZXIocHJvcCA9PiBwcm9wICE9PSAnb3B0aW9ucycpXG4gICAgICAgICAgICAuZm9yRWFjaCh0aGlzLm1hcmtUb3VjaGVkKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmlzQ3VycmVudGx5U2hvd24pIHtcbiAgICAgICAgICAgIFN3YWwuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNob3dzIHRoZSBTd2VldEFsZXJ0LlxuICAgICAqXG4gICAgICogUmV0dXJucyB0aGUgU3dlZXRBbGVydDIgcHJvbWlzZSBmb3IgY29udmVuaWVuY2UgYW5kIHVzZSBpbiBjb2RlIGJlaGluZCB0ZW1wbGF0ZXMuXG4gICAgICogT3RoZXJ3aXNlLCAoY29uZmlybSk9XCJteUhhbmRsZXIoJGV2ZW50KVwiIGFuZCAoY2FuY2VsKT1cIm15SGFuZGxlcigkZXZlbnQpXCIgY2FuIGJlIHVzZWQgaW4gdGVtcGxhdGVzLlxuICAgICAqL1xuICAgIHB1YmxpYyBzaG93KCk6IFByb21pc2U8YW55PiB7XG4gICAgICAgIC8vPT4gQnVpbGQgdGhlIFN3ZWV0QWxlcnQyIG9wdGlvbnNcbiAgICAgICAgY29uc3Qgb3B0aW9uczogU3dlZXRBbGVydE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAvLz0+IE1lcmdlIHdpdGggdGhlIGRlZmF1bHQgbW9kdWxlLWxldmVsIG9wdGlvbnNcbiAgICAgICAgICAgIC4uLnRoaXMuZGVmYXVsdFN3YWxPcHRpb25zLFxuXG4gICAgICAgICAgICAvLz0+IE1lcmdlIHdpdGggY2FsY3VsYXRlZCBvcHRpb25zIHNldCBmb3IgdGhhdCBzcGVjaWZpYyBzd2FsXG4gICAgICAgICAgICAuLi50aGlzLm9wdGlvbnMsXG5cbiAgICAgICAgICAgIC8vPT4gSGFuZGxlIG1vZGFsIGxpZmVjeWNsZSBldmVudHNcbiAgICAgICAgICAgIG9uQmVmb3JlT3BlbjogKG1vZGFsRWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYmVmb3JlT3Blbi5lbWl0KHsgbW9kYWxFbGVtZW50IH0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgb25PcGVuOiAobW9kYWxFbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0N1cnJlbnRseVNob3duID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW4uZW1pdCh7IG1vZGFsRWxlbWVudCB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG9uQ2xvc2U6IChtb2RhbEVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzQ3VycmVudGx5U2hvd24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlLmVtaXQoeyBtb2RhbEVsZW1lbnQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy89PiBTaG93IHRoZSBTd2FsIVxuICAgICAgICBjb25zdCBwcm9taXNlID0gU3dhbC5maXJlKG9wdGlvbnMpO1xuXG4gICAgICAgIC8vPT4gSGFuZGxlIChjb25maXJtKSBhbmQgKGNhbmNlbCkgQE91dHB1dHNcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXN0cmluZy1saXRlcmFsXG4gICAgICAgIGNvbnN0IHVzZVJlamVjdGlvbnMgPSAob3B0aW9ucyBhcyB7IHVzZVJlamVjdGlvbnM/OiBib29sZWFuIH0pLnVzZVJlamVjdGlvbnM7XG5cbiAgICAgICAgcHJvbWlzZS50aGVuKFxuICAgICAgICAgICAgcmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodXNlUmVqZWN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpcm0uZW1pdChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maXJtLmVtaXQocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbC5lbWl0KHJlc3VsdC5kaXNtaXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodXNlUmVqZWN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbC5lbWl0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIC8vPT4gUmV0dXJuIHRoZSB1bmFsdGVyZWQgcHJvbWlzZVxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG59XG4iLCJpbXBvcnQge1xuICAgIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgQ29tcG9uZW50UmVmLCBEaXJlY3RpdmUsIEV2ZW50RW1pdHRlciwgSG9zdExpc3RlbmVyLCBJbnB1dCwgT25EZXN0cm95LCBPbkluaXQsIE91dHB1dCxcbiAgICBWaWV3Q29udGFpbmVyUmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IFN3YWwsIHsgU3dlZXRBbGVydEFycmF5T3B0aW9ucywgU3dlZXRBbGVydE9wdGlvbnMgfSBmcm9tICdzd2VldGFsZXJ0Mic7XG5pbXBvcnQgeyBTd2FsQ29tcG9uZW50IH0gZnJvbSAnLi9zd2FsLmNvbXBvbmVudCc7XG5cbi8qKlxuICogW3N3YWxdIGRpcmVjdGl2ZS4gSXQgdGFrZXMgYSB2YWx1ZSB0aGF0IGRlZmluZXMgdGhlIFN3ZWV0IEFsZXJ0IGFuZCBjYW4gYmUgb2YgdGhyZWUgdHlwZXM6XG4gKlxuICogMSkgQSBzaW1wbGUgYXJyYXkgb2YgdHdvIG9yIHRocmVlIHN0cmluZ3MgZGVmaW5pbmcgW3RpdGxlLCB0ZXh0LCB0eXBlXSAtIHRoZSB0eXBlIGJlaW5nIG9wdGlvbmFsLCBleDpcbiAqXG4gKiAgICA8YnV0dG9uIFtzd2FsXT1cIlsnVGl0bGUnLCAnVGV4dCddXCI+Q2xpY2sgbWU8L2J1dHRvbj5cbiAqXG4gKiAyKSBBIG5hdGl2ZSBTd2VldEFsZXJ0MiBvcHRpb25zIG9iamVjdCwgZXg6XG4gKlxuICogICAgPGJ1dHRvbiBbc3dhbF09XCJ7IHRpdGxlOiAnVGl0bGUnLCB0ZXh0OiAnVGV4dCcgfVwiPkNsaWNrIG1lPC9idXR0b24+XG4gKlxuICogMykgQSByZWZlcmVuY2UgdG8gYW4gZXhpc3RpbmcgU3dhbENvbXBvbmVudCBpbnN0YW5jZSBmb3IgbW9yZSBhZHZhbmNlZCB1c2VzLCBleDpcbiAqXG4gKiAgICA8YnV0dG9uIFtzd2FsXT1cIm15U3dhbFwiPkNsaWNrIG1lPC9idXR0b24+XG4gKiAgICA8c3dhbCAjbXlTd2FsIHRpdGxlPVwiVGl0bGVcIiB0ZXh0PVwiVGV4dFwiPjwvc3dhbD5cbiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbc3dhbF0nXG59KVxuZXhwb3J0IGNsYXNzIFN3YWxEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG4gICAgLyoqXG4gICAgICogU3dlZXRBbGVydDIgb3B0aW9ucyBvciBhIFN3YWxDb21wb25lbnQgaW5zdGFuY2UuXG4gICAgICogU2VlIHRoZSBjbGFzcyBkb2MgYmxvY2sgZm9yIG1vcmUgaW5mb3JtYXRpb25zLlxuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBzZXQgc3dhbChvcHRpb25zOiBTd2FsQ29tcG9uZW50IHwgU3dlZXRBbGVydE9wdGlvbnMgfCBTd2VldEFsZXJ0QXJyYXlPcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zIGluc3RhbmNlb2YgU3dhbENvbXBvbmVudCkge1xuICAgICAgICAgICAgdGhpcy5zd2FsSW5zdGFuY2UgPSBvcHRpb25zO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgICAgICAgIHRoaXMuc3dhbE9wdGlvbnMgPSBTd2FsLmFyZ3NUb1BhcmFtcyhvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3dhbE9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW1pdHMgd2hlbiB0aGUgdXNlciBjbGlja3MgXCJDb25maXJtXCIuXG4gICAgICogQmVhcnMgYSB2YWx1ZSB3aGVuIHVzaW5nIFwiaW5wdXRcIiwgcmVzb2x2ZWQgXCJwcmVDb25maXJtXCIsIGV0Yy5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICogICAgIHB1YmxpYyBoYW5kbGVDb25maXJtKGVtYWlsOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgKiAgICAgICAgIC8vIC4uLiBzYXZlIHVzZXIgZW1haWxcbiAgICAgKiAgICAgfVxuICAgICAqL1xuICAgIEBPdXRwdXQoKSBwdWJsaWMgcmVhZG9ubHkgY29uZmlybSA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHMgd2hlbiB0aGUgdXNlciBjbGlja3MgXCJDYW5jZWxcIiAob3IgZGlzbWlzc2VzIHRoZSBtb2RhbCBieSBhbnkgb3RoZXIgd2F5KS5cbiAgICAgKiBCeSBkZWZhdWx0LCBpdCB3aWxsIGVtaXQgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSByZWFzb24gZm9yIHdoaWNoIHRoZSBTd2VldEFsZXJ0IGhhcyBiZWVuIGNsb3NlZCwgb3IgdGhlXG4gICAgICogdmFsdWUgb2YgYSByZWplY3RlZCBcInByZUNvbmZpcm1cIi5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICogICAgIHB1YmxpYyBoYW5kbGVDYW5jZWwocmVhc29uOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgKiAgICAgICAgIC8vIHJlYXNvbiBjYW4gYmUgJ2NhbmNlbCcsICdvdmVybGF5JywgJ2Nsb3NlJywgYW5kICd0aW1lcidcbiAgICAgKiAgICAgICAgIC8vIC4uLiBkbyBzb21ldGhpbmdcbiAgICAgKiAgICAgfVxuICAgICAqL1xuICAgIEBPdXRwdXQoKSBwdWJsaWMgcmVhZG9ubHkgY2FuY2VsID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSB1c2VyIGRvZXMgbm90IHByb3ZpZGVzIGEgU3dhbENvbXBvbmVudCBpbnN0YW5jZSwgd2UgY3JlYXRlIGl0IG9uLXRoZS1mbHkgYW5kIGFzc2lnbiB0aGUgcGxhaW4tb2JqZWN0XG4gICAgICogb3B0aW9ucyB0byBpdC5cbiAgICAgKiBUaGlzIGZpZWxkcyBrZWVwcyBhIHJlZmVyZW5jZSB0byB0aGUgZHluYW1pY2FsbHktY3JlYXRlZCA8c3dhbD4sIHRvIGRlc3Ryb3kgaXQgYWxvbmcgdGhpcyBkaXJlY3RpdmUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgcHJpdmF0ZSBzd2FsUmVmOiBDb21wb25lbnRSZWY8U3dhbENvbXBvbmVudD47XG5cbiAgICAvKipcbiAgICAgKiBBbiBpbnN0YW5jZSBvZiB0aGUgPHN3YWw+IGNvbXBvbmVudCB0aGF0IHRoaXMgZGlyZWN0aXZlIGNvbnRyb2xzLlxuICAgICAqIENvdWxkIGJlIGFuIGluc3RhbmNlIHBhc3NlZCBieSB0aGUgdXNlciwgb3RoZXJ3aXNlIGl0J3MgdGhlIGluc3RhbmNlIHdlJ3ZlIGR5bmFtaWNhbGx5IGNyZWF0ZWQuXG4gICAgICovXG4gICAgcHJpdmF0ZSBzd2FsSW5zdGFuY2U6IFN3YWxDb21wb25lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBIb2xkcyB0aGUgbmF0aXZlIFN3ZWV0QWxlcnQyIG9wdGlvbnMuXG4gICAgICogRW1wdHkgd2hlbiB0aGUgdXNlciBwYXNzZWQgYW4gZXhpc3RpbmcgU3dhbENvbXBvbmVudCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBwcml2YXRlIHN3YWxPcHRpb25zOiBTd2VldEFsZXJ0T3B0aW9ucztcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSB2aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IHJlc29sdmVyOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIpIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPbkluaXQgbGlmZWN5Y2xlIGhhbmRsZXIuXG4gICAgICogQ3JlYXRlcyBhIFN3YWxDb21wb25lbnQgaW5zdGFuY2UgaWYgdGhlIHVzZXIgZGlkbid0IHByb3ZpZGVkIG9uZSBhbmQgYmluZHMgb24gdGhhdCBjb21wb25lbnQgKGNvbmZpcm0pIGFuZFxuICAgICAqIChjYW5jZWwpIG91dHB1dHMgdG8gcmVlbWl0IG9uIHRoZSBkaXJlY3RpdmUuXG4gICAgICovXG4gICAgcHVibGljIG5nT25Jbml0KCk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuc3dhbEluc3RhbmNlKSB7XG4gICAgICAgICAgICBjb25zdCBmYWN0b3J5ID0gdGhpcy5yZXNvbHZlci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShTd2FsQ29tcG9uZW50KTtcblxuICAgICAgICAgICAgdGhpcy5zd2FsUmVmID0gdGhpcy52aWV3Q29udGFpbmVyUmVmLmNyZWF0ZUNvbXBvbmVudChmYWN0b3J5KTtcbiAgICAgICAgICAgIHRoaXMuc3dhbEluc3RhbmNlID0gdGhpcy5zd2FsUmVmLmluc3RhbmNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT25EZXN0cm95IGxpZmVjeWNsZSBoYW5kbGVyLlxuICAgICAqIERlc3Ryb3lzIHRoZSBkeW5hbWljYWxseS1jcmVhdGVkIFN3YWxDb21wb25lbnQgYW5kIHVuc3Vic2NyaWJlcyBmcm9tIHRoYXQgY29tcG9uZW50J3MgKGNvbmZpcm0pIGFuZCAoY2FuY2VsKS5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnN3YWxSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuc3dhbFJlZi5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGljayBoYW5kbGVyLlxuICAgICAqIFRoZSBkaXJlY3RpdmUgbGlzdGVucyBmb3Igb25jbGljayBldmVudHMgb24gaXRzIGhvc3QgZWxlbWVudC5cbiAgICAgKiBXaGVuIHRoaXMgaGFwcGVucywgaXQgc2hvd3MgdGhlIDxzd2FsPiBhdHRhY2hlZCB0byB0aGlzIGRpcmVjdGl2ZS5cbiAgICAgKi9cbiAgICBASG9zdExpc3RlbmVyKCdjbGljaycsIFsnJGV2ZW50J10pXG4gICAgcHVibGljIG9uSG9zdENsaWNrZWQoZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgIGlmICh0aGlzLnN3YWxPcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnN3YWxJbnN0YW5jZS5vcHRpb25zID0gdGhpcy5zd2FsT3B0aW9ucztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbmZpcm1TdWIgPSB0aGlzLnN3YWxJbnN0YW5jZS5jb25maXJtLmFzT2JzZXJ2YWJsZSgpLnN1YnNjcmliZSh2ID0+IHRoaXMuY29uZmlybS5lbWl0KHYpKTtcbiAgICAgICAgY29uc3QgY2FuY2VsU3ViID0gdGhpcy5zd2FsSW5zdGFuY2UuY2FuY2VsLmFzT2JzZXJ2YWJsZSgpLnN1YnNjcmliZSh2ID0+IHRoaXMuY2FuY2VsLmVtaXQodikpO1xuXG4gICAgICAgIHRoaXMuc3dhbEluc3RhbmNlLnNob3coKS50aGVuKHVuc3Vic2NyaWJlKTtcblxuICAgICAgICBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgICAgIGNvbmZpcm1TdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIGNhbmNlbFN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgSW5wdXQsIFRlbXBsYXRlUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbi8qKlxuICogQGludGVybmFsXG4gKiBIb2xkcyBhIGNvbnN1bWVyJ3MgQW5ndWxhciB0ZW1wbGF0ZSBhbmQgZGlzcGxheXMgaXQgb24gYSBTd2VldCBBbGVydC5cbiAqIFNlZSBTd2FsUGFydGlhbERpcmVjdGl2ZSBmb3IgaW5mbyBhYm91dCB0aGUgY292ZXJlZCBmZWF0dXJlLlxuICovXG5AQ29tcG9uZW50KHtcbiAgICB0ZW1wbGF0ZTogJzxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJ0ZW1wbGF0ZVwiPjwvbmctY29udGFpbmVyPicsXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgU3dhbFBhcnRpYWxDb21wb25lbnQge1xuICAgIEBJbnB1dCgpIHB1YmxpYyB0ZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55Pjtcbn1cbiIsImltcG9ydCB7XG4gICAgQXBwbGljYXRpb25SZWYsIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgQ29tcG9uZW50UmVmLCBEaXJlY3RpdmUsIEhvc3QsIEluamVjdG9yLCBJbnB1dCwgT25EZXN0cm95LCBPbkluaXQsXG4gICAgVGVtcGxhdGVSZWZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFN3YWxQYXJ0aWFsVGFyZ2V0cyB9IGZyb20gJy4vc3dhbC1wYXJ0aWFsLXRhcmdldHMnO1xuaW1wb3J0IHsgU3dhbFBhcnRpYWxDb21wb25lbnQgfSBmcm9tICcuL3N3YWwtcGFydGlhbC5jb21wb25lbnQnO1xuaW1wb3J0IHsgU3dhbENvbXBvbmVudCB9IGZyb20gJy4vc3dhbC5jb21wb25lbnQnO1xuXG4vKipcbiAqIEEgc3RydWN0dXJhbCBkaXJlY3RpdmUgdGhhdCBsZXRzIHlvdSB1c2UgQW5ndWxhciB0ZW1wbGF0ZXMgaW5zaWRlIG9mIFN3ZWV0IEFsZXJ0cy5cbiAqIFRoZXJlIGFyZSBkaWZmZXJlbnQgdGFyZ2V0YWJsZSB6b25lcyBpbiBhIFN3ZWV0IEFsZXJ0OiB0aXRsZSwgY29udGVudCwgY29uZmlybUJ1dHRvbiwgY2FuY2VsQnV0dG9uLCBidXR0b25zV3JhcHBlci5cbiAqIFRoZSBkZWZhdWx0IHRhcmdldCBpcyB0aGUgY29udGVudCB6b25lLlxuICpcbiAqIFVzYWdlIGluIHlvdXIgY29tcG9uZW50J3MgVHlwZVNjcmlwdCBjb2RlLWJlaGluZCAoaWYgeW91IHVzZSBhbm90aGVyIHRhcmdldCB0aGFuIFwiY29udGVudFwiKTpcbiAqXG4gKiAgICAgQENvbXBvbmVudCh7IC4uLiB9KVxuICogICAgIGV4cG9ydCBjbGFzcyBNeUNvbXBvbmVudCB7XG4gKiAgICAgICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgc3dhbFRhcmdldHM6IFN3YWxQYXJ0aWFsVGFyZ2V0cykge1xuICogICAgICAgICB9XG4gKiAgICAgfVxuICpcbiAqIFVzYWdlIGluIHRoZSB0ZW1wbGF0ZTpcbiAqXG4gKiAgICAgPHN3YWwgdGl0bGU9XCJGaWxsIHRoZSBmb3JtXCIgKGNvbmZpcm0pPVwiY29uZmlybUhhbmRsZXIoKVwiPlxuICogICAgICAgICA8IS0tIFRoaXMgZm9ybSB3aWxsIGJlIGRpc3BsYXllZCBhcyB0aGUgYWxlcnQgbWFpbiBjb250ZW50XG4gKiAgICAgICAgICAgICAgVGFyZ2V0cyB0aGUgYWxlcnQncyBtYWluIGNvbnRlbnQgem9uZSBieSBkZWZhdWx0IC0tPlxuICogICAgICAgICA8Zm9ybSAqc3dhbFBhcnRpYWwgW2Zvcm1Db250cm9sXT1cIm15Rm9ybVwiPlxuICogICAgICAgICAgICAgLi4uXG4gKiAgICAgICAgIDwvZm9ybT5cbiAqXG4gKiAgICAgICAgIDwhLS0gVGhpcyB0YXJnZXRzIHRoZSBjb25maXJtIGJ1dHRvbidzIGlubmVyIGNvbnRlbnRcbiAqICAgICAgICAgICAgICBOb3RpY2UgdGhlIHVzYWdlIG9mIG5nLWNvbnRhaW5lciB0byBhdm9pZCBjcmVhdGluZyBhbiB1c2VsZXNzIERPTSBlbGVtZW50IGluc2lkZSB0aGUgYnV0dG9uIC0tPlxuICogICAgICAgICA8bmctY29udGFpbmVyICpzd2FsUGFydGlhbD1cInN3YWxUYXJnZXRzLmNvbmZpcm1CdXR0b25cIj5cbiAqICAgICAgICAgICAgICBTZW5kICh7eyBzZWNvbmRzTGVmdCB9fSBzZWNvbmRzIGxlZnQpXG4gKiAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICogICAgIDxzd2FsPlxuICovXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1tzd2FsUGFydGlhbF0nXG59KVxuZXhwb3J0IGNsYXNzIFN3YWxQYXJ0aWFsRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuICAgIC8qKlxuICAgICAqIFRha2VzIGEgXCJwYXJ0aWFsIHRhcmdldFwiIG9yIG5vdGhpbmcgKHdpbGwgdGFyZ2V0IG1haW4gY29udGVudCB6b25lIGJ5IGRlZmF1bHQpLlxuICAgICAqXG4gICAgICogU2VlIHRoZSB7QGxpbmsgU3dhbFBhcnRpYWxUYXJnZXRzfSBzZXJ2aWNlIHRvIHNlZSB0aGUgYXZhaWxhYmxlIHRhcmdldHMuXG4gICAgICogU2VlIHRoZSBjbGFzcyBkb2MgYmxvY2sgZm9yIG1vcmUgaW5mb3JtYXRpb25zLlxuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBzd2FsUGFydGlhbDogKCkgPT4gSFRNTEVsZW1lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBIb2xkcyB0aGUgY29tcG9uZW50IHJlZmVyZW5jZSBvZiB0aGUgY29udHJvbGxlZCBTd2FsUGFydGlhbENvbXBvbmVudCB0byBkZXN0cm95IGl0IHdoZW4gbm8gbG9uZ2VyIG5lZWRlZC5cbiAgICAgKi9cbiAgICBwcml2YXRlIHBhcnRpYWxSZWY6IENvbXBvbmVudFJlZjxTd2FsUGFydGlhbENvbXBvbmVudD47XG5cbiAgICBwcml2YXRlIGJlZm9yZU9wZW5TdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcbiAgICBwcml2YXRlIGNsb3NlU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSByZXNvbHZlcjogQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IGluamVjdG9yOiBJbmplY3RvcixcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBhcHA6IEFwcGxpY2F0aW9uUmVmLFxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxhbnk+LFxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IHN3YWxUYXJnZXRzOiBTd2FsUGFydGlhbFRhcmdldHMsXG4gICAgICAgIEBIb3N0KCkgcHJpdmF0ZSByZWFkb25seSBzd2FsQ29tcG9uZW50OiBTd2FsQ29tcG9uZW50KSB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlcyB0byB0aGUgdGhlIFN3ZWV0IEFsZXJ0IGFwcGVhcmFuY2UvZGlzYXBwZWFyYW5jZSB0byBjcmVhdGUvZGVzdHJveSB0aGUgU3dhbFBhcnRpYWxDb21wb25lbnQgdGhhdCB3aWxsXG4gICAgICogcmVjZWl2ZSB0aGUgY29uc3VtZXIncyB0ZW1wbGF0ZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuYmVmb3JlT3BlblN1YnNjcmlwdGlvbiA9IHRoaXMuc3dhbENvbXBvbmVudC5iZWZvcmVPcGVuLmFzT2JzZXJ2YWJsZSgpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAvLz0+IENyZWF0ZSB0aGUgU3dhbFBhcnRpYWxDb21wb25lbnQgb24gdGhlIHRhcmdldCBET00gbm9kZSBpbiB0aGUgU3dlZXQgQWxlcnRcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldEVsID0gdGhpcy5zd2FsUGFydGlhbCA/IHRoaXMuc3dhbFBhcnRpYWwoKSA6IHRoaXMuc3dhbFRhcmdldHMuY29udGVudCgpO1xuICAgICAgICAgICAgY29uc3QgZmFjdG9yeSA9IHRoaXMucmVzb2x2ZXIucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoU3dhbFBhcnRpYWxDb21wb25lbnQpO1xuXG4gICAgICAgICAgICB0aGlzLnBhcnRpYWxSZWYgPSBmYWN0b3J5LmNyZWF0ZSh0aGlzLmluamVjdG9yLCBbXSwgdGFyZ2V0RWwpO1xuXG4gICAgICAgICAgICAvLz0+IEFwcGx5IHRoZSBjb25zdW1lcidzIHRlbXBsYXRlIG9uIHRoZSBjb21wb25lbnRcbiAgICAgICAgICAgIHRoaXMucGFydGlhbFJlZi5pbnN0YW5jZS50ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGVSZWY7XG5cbiAgICAgICAgICAgIC8vPT4gTWFrZSB0aGUgQW5ndWxhciBhcHAgYXdhcmUgb2YgdGhhdCBkZXRhY2hlZCB2aWV3IHNvIGNoYW5nZSBkZXRlY3Rpb24gd29ya3NcbiAgICAgICAgICAgIHRoaXMuYXBwLmF0dGFjaFZpZXcodGhpcy5wYXJ0aWFsUmVmLmhvc3RWaWV3KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5jbG9zZVN1YnNjcmlwdGlvbiA9IHRoaXMuc3dhbENvbXBvbmVudC5jbG9zZS5hc09ic2VydmFibGUoKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgLy89PiBEZXRhY2ggdGhlIHBhcnRpYWwgY29tcG9uZW50IGZyb20gdGhlIGFwcCBhbmQgZGVzdHJveSBpdFxuICAgICAgICAgICAgdGhpcy5hcHAuZGV0YWNoVmlldyh0aGlzLnBhcnRpYWxSZWYuaG9zdFZpZXcpO1xuICAgICAgICAgICAgdGhpcy5wYXJ0aWFsUmVmLmRlc3Ryb3koKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmVzIGZyb20gdGhlIFN3ZWV0IEFsZXJ0IGFwcGVhcmFuY2UvZGlzYXBwZWFyYW5jZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuYmVmb3JlT3BlblN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLmNsb3NlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE1vZHVsZVdpdGhQcm92aWRlcnMsIE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTd2VldEFsZXJ0T3B0aW9ucyB9IGZyb20gJ3N3ZWV0YWxlcnQyJztcbmltcG9ydCB7IHN3YWxEZWZhdWx0c1Byb3ZpZGVyIH0gZnJvbSAnLi9kaSc7XG5pbXBvcnQgeyBTd2FsUGFydGlhbFRhcmdldHMgfSBmcm9tICcuL3N3YWwtcGFydGlhbC10YXJnZXRzJztcbmltcG9ydCB7IFN3YWxQYXJ0aWFsQ29tcG9uZW50IH0gZnJvbSAnLi9zd2FsLXBhcnRpYWwuY29tcG9uZW50JztcbmltcG9ydCB7IFN3YWxQYXJ0aWFsRGlyZWN0aXZlIH0gZnJvbSAnLi9zd2FsLXBhcnRpYWwuZGlyZWN0aXZlJztcbmltcG9ydCB7IFN3YWxDb21wb25lbnQgfSBmcm9tICcuL3N3YWwuY29tcG9uZW50JztcbmltcG9ydCB7IFN3YWxEaXJlY3RpdmUgfSBmcm9tICcuL3N3YWwuZGlyZWN0aXZlJztcblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgU3dhbENvbXBvbmVudCwgU3dhbFBhcnRpYWxEaXJlY3RpdmUsIFN3YWxQYXJ0aWFsQ29tcG9uZW50LFxuICAgICAgICBTd2FsRGlyZWN0aXZlXG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgU3dhbFBhcnRpYWxUYXJnZXRzXG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZVxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBTd2FsQ29tcG9uZW50LCBTd2FsUGFydGlhbERpcmVjdGl2ZSxcbiAgICAgICAgU3dhbERpcmVjdGl2ZVxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIFN3YWxDb21wb25lbnQsIFN3YWxQYXJ0aWFsQ29tcG9uZW50XG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBTd2VldEFsZXJ0Mk1vZHVsZSB7XG4gICAgcHVibGljIHN0YXRpYyBmb3JSb290KGRlZmF1bHRTd2FsT3B0aW9ucz86IFN3ZWV0QWxlcnRPcHRpb25zKTogTW9kdWxlV2l0aFByb3ZpZGVycyB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogU3dlZXRBbGVydDJNb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtzd2FsRGVmYXVsdHNQcm92aWRlcihkZWZhdWx0U3dhbE9wdGlvbnMpXVxuICAgICAgICB9O1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJJbmplY3Rpb25Ub2tlbiIsIkV2ZW50RW1pdHRlciIsIkNvbXBvbmVudCIsIkNoYW5nZURldGVjdGlvblN0cmF0ZWd5IiwiSW5qZWN0IiwiSW5wdXQiLCJPdXRwdXQiLCJEaXJlY3RpdmUiLCJWaWV3Q29udGFpbmVyUmVmIiwiQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyIiwiSG9zdExpc3RlbmVyIiwiSW5qZWN0b3IiLCJBcHBsaWNhdGlvblJlZiIsIlRlbXBsYXRlUmVmIiwiSG9zdCIsIk5nTW9kdWxlIiwiQ29tbW9uTW9kdWxlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7QUFPQTs7Ozs7UUFBQTtZQUNvQixVQUFLLEdBQUcsY0FBTSxPQUFBLElBQUksQ0FBQyxRQUFRLEVBQUUsR0FBQSxDQUFDO1lBRTlCLFlBQU8sR0FBRyxjQUFNLE9BQUEsSUFBSSxDQUFDLFVBQVUsRUFBRSxHQUFBLENBQUM7WUFFbEMsWUFBTyxHQUFHLGNBQU0sT0FBQSxJQUFJLENBQUMsVUFBVSxFQUFFLEdBQUEsQ0FBQztZQUVsQyxrQkFBYSxHQUFHLGNBQU0sT0FBQSxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsR0FBQSxDQUFDO1lBRTlDLGlCQUFZLEdBQUcsY0FBTSxPQUFBLElBQUksQ0FBQyxlQUFlLEVBQUUsR0FBQSxDQUFDO1lBRTVDLFdBQU0sR0FBRyxjQUFNLE9BQUEsSUFBSSxDQUFDLFNBQVMsRUFBRSxHQUFBLENBQUM7U0FDbkQ7UUFB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